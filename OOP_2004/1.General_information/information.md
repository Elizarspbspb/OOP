# **Глава 1**
# **Общие сведения**
## **1. Для чего нужно объектно-ориентированное программирование?**

С, Pascal, FORTRAN и др. сходные с ними языки программирования относятся к категории ***процедурных языков***. Программы, написанные на процедурных языках, представляют собой последовательности инструкций.

Функция (подпрограмма, процедура) - средство, облегчающее восприятие при
чтении текста программы. Программа, построенная на основе процедурного метода, раз-
делена на функции, каждая из которых выполняет некоторую законченную последовательность действий и имеет явно выраженные связи. Модуль - объединение нескольких функций программы(зачастую модуль представляет собой отдельный файл).

#### **Недостаток процедурно-ориентированных языков!**

***1. Неограниченный доступ функций к глобальным данным.*** 

Число возможных связей между глобальными переменными и функциями может быть очень велико

***2. Разделение данных и функций, являющееся основой структурного подхода, плохо отображает картину реального мира.***

Усложняется структура программы. В программу становится трудно вносить изменения. Изменение
структуры глобальных данных может потребовать переписывания всех функций

## **2. Характеристики объектно-ориентированных языков**

***Объект*** в объектно-ориентированном программировании — это модель или абстракция реальной сущности в программной системе. Двумя основными компонентами объекта являются данные и функции, которые выполняют действия над данными. Объекты отображают объекты реального мира точнее, чем функции.

***Класс*** является своего рода формой, определяющей, какие данные и функции будут включены в объект класса. При объявлении класса не создаются никакие объекты этого класса. Когда мы говорим об объектах, мы говорим, что они являются экземплярами классов.

***Наследование*** в ООП как и у функция в про-
цедурном программировании, — призвана сократить размер кода и упростить связи между
элементами программы. Класс также может породить множество подклассов. В C++ класс, который порождает все остальные классы, называется базовым классом, остальные классы наследуют его свойства, одновременно
обладая собственными свойствами. Такие классы называются производными.

***Возможность повторного использования кода.*** Разработанный класс может быть использован в других программах. Аналогичным свойством в процедурном программировании обладают библиотеки функций, которые можно включать в различные программные проекты.

Одним из достоинств объектов является то, что они дают пользователю возможность создавать свои ***собственные типы данных.***

***Полиморфизм*** - использование операций и функций различным образом в зависимости от
того, с какими типами величин они работают. Когда существующая операция, например = или +, наделяется возможностью совершать действия над операндами нового типа, говорят, что такая операция является перегруженной. 

Возможность выполнения оператором или функцией различных действий в зависимости от типа операндов называется ***полиморфизм***.

***Перегрузка*** представляет собой частный случай полиморфизма и является важным инструментом ООП. Операция, выполняющая заданные действия над пользовательским типом
данных, называется ***перегруженной.***

Защита данных от несанкционированного доступа другими функциями называется ***сокрытием данных.***

***Инкапсуляция*** - объединение данных и функций. Это принцип, согласно которому внутреннее устройство сущностей нужно объединять в специальной «оболочке» и скрывать от вмешательств извне. Доступ возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.

Если язык обеспечивает возможность создания пользовательских типов данных, то говорят, что язык называется ***расширяемым***.

## **3. С++ и С**

C++ является расширением языка С: любая конструкция на языке C является корректной в C++; в то же время обратное неверно. Наиболее значительные нововведения, присутствующие в C++, касаются ***классов, объектов и ООП*** (первоначальное название языка C++ — «С с классами»). Тем не менее имеются и другие усовершенствования, связанные со способами организации ввода/вывода и комментариями.
***С++ объектно-ориентированный язык программирования.***

В C++ функцию, входящую в состав класса, называют - функция-член класса. Однако ***Метод*** в объектно-ориентированном программировании — это функция или процедура, принадлежащая какому-то классу или объекту.


## **4. Универсальный язык моделирования (UML)**

***UML*** можно условно называть графическим языком, предназначенным для моделирования компьютерных программ. Создание наглядной визуальной интерпретации.

Наиболее важным средством UML является набор различных видов диаграмм. Диаграммы классов иллюстрируют отношения между различными классами, диаграммы объектов — между отдельными объектами, диаграммы связей
отражают связь объектов во времени и т. д.

UML является лишь средством для иллюстрирования
разрабатываемого проекта.

# **Глава 4**
# **Структуры**
***Структура*** является объединением простых переменных. Эти переменные могут иметь различные типы: int, float и т. д. (Переменные, входящие в состав структуры, называются ***полями*** структуры.
Синтаксис структуры идентичен синтаксису класса. Отличие структуры от класса заключается в следующем: структуры, как правило, используют в качестве объединения данных, а классы — в качестве объединения данных и функций. В структуре все поля по-умолчанию открытые, а в классе закрытые. Одним из достоинств классов является возможность определять сложение и другие операции над пользовательскими типами данных.
Само определение структуры не создает никаких переменных - не происходит ни выделения физической памяти, ни объявления переменной. А при создании объекта структуры выделяется память. Под структурную переменную отводится столько памяти, сколько достаточно для хранения всех ее полей. Доступ к полям структуры осуществляются с помощью операции ***доступ к полю структуры***. Проводить мат. действия с объектами невозможно без переопределения операции.
***Перечисления*** - пользовательский тип данных. Объявление типа начинается со слова ***enum*** и содержит перечисление всех возможных значений переменных создаваемого типа. Инициализируются целыми значениями от 0 и т.д., перечисление констант. 

# **Глава 5**
# **Функции**
Наиболее важной причиной использования функций служит необходимость концептуализировать структуру программы.
Любая последовательность операторов, встречающаяся в программе более одного раза, будучи вынесенной в отдельную функцию, сокращает размер программы.
Что необходимо добавить в программу для использования дополнительных функций? Обязательными являются три компонента: ***объявление функции***, ее ***определение*** и ***вызовы***.
***Объявления функций*** также называют ***прототипами функций***, поскольку они являются неким общим представлением или описанием функций. Прототип говорит компилятору о том, что «функция, имеющая данные атрибуты, будет написана позже, и 
можно вызывать эту функцию до того, как будет обнаружен ее код». Информацию о функции, содержащуюся в ее объявлении (тип возвращаемого значения, а также число и типы аргументов функции) также иногда называют ***сигнатурой*** функции.
Переменные, используемые внутри функции для хранения значений аргументов, называются параметрами.
Способ передачи аргументов, при котором функция создает копии передаваемых значений, называется ***передачей аргументов по значению***.
В случае, если функция возвращает значение, тип этого значения должен быть определен. 
Тип возвращаемого значения указывается перед именем функции при объявлении и определении функции.
Количество аргументов у функции может быть сколь угодно большим, но возвращаемое значение всегда только одно. А если надо вернуть больше, то возможна передача аргументов по ссылке или вернуть структурную переменную с полями.
Если же вы не укажете возвращаемый тип данных при объявлении функции, то по умолчанию возвращаемым типом будет int.
Ссылка является псевдонимом, или альтернативным именем переменной. Вместо того чтобы передавать функции значение переменной, ей передается ссылка на эту переменную (адрес переменной-аргумента в памяти).
Если какие-либо аргументы передаются в функцию по ссылке, то в прототипе функции необходимо с помощью знака & указывать соответствующий параметр-ссылку.
В языке C не существует понятия ***ссылка***. Схожие с ссылками возможности в С обеспечивают указатели, хотя зачастую их применение менее удобно. 
Создание ссылочного механизма в C++ было обусловлено стремлением обеспечить гибкость языка в ситуациях, связанных с использованием как объектов, так и простых переменных.
Третьим способом передачи аргументов в функцию является использование указателей. Мы рассмотрим этот способ в главе 10 «Указатели».
***Перегруженная функция*** выполняет различные действия, зависящие от типов данных, передаваемых ей в качестве аргументов.
***1. Переменное число аргументов функции*** 
void repchar();			// прототипы
void repchar(char);
void repchar(char, int);
***2. Различные типы аргументов***
void engldisp(Distance);	// прототипы
void engldisp(float);
***Рекурсия***
Существование функций делает возможным использование такого средства программирования, как рекурсия. Рекурсия позволяет функции вызывать саму себя на выполнение.
Каждая рекурсивная функция должна включать в себя условие окончания рекурсии. В противном случае рекурсия будет происходить бесконечно, что приведет к аварийному завершению программы.
***Встраиваемые функции***
Использование функций является экономичным (избавляет от дублирования кода). Когда компилятор встречает вызов функции, он генерирует команду перехода в эту функцию. После выполнения функции осуществляется переход на оператор, следующий за вызовом функции.
Использование функций, наряду с сокращением размера памяти, увеличивает время выполнения программы. Для выполнения функции должны быть сгенерированы команды переходов (инструкция ассемблера CALL), команды, сохраняющие значения регистров процессора, команды, помещающие в стек и извлекающие из стека аргументы функции, команды, восстанавливающие значения регистров после выполнения функции, и наконец, команда перехода из функции обратно в программу.
Для того чтобы сократить время выполнения небольших функций, можно дать указание компилятору, чтобы при каждом вызове такой функции вместо команды перехода производилась подстановка операторов, выполняемых функцией, в код программы.
Длинные повторяющиеся последовательности действий лучше объединять в обычные функции, поскольку экономия памяти в этом случае оправдывает накладные расходы на время выполнения программы. Но если вынести в функцию небольшой фрагмент кода, то выигрыш от экономии памяти будет мал, а дополнительные временные затраты останутся почти на том же уровне, что и для функции большого объема. Решением данной проблемы служит использование встраиваемых функций.
Встраиваемые функции ***inline*** пишутся так же, как и обычные, но при компиляции их исполняемый код вставляется, или встраивается, в исполняемый код программы. Встраиваемыми следует делать только очень короткие функции (один-два оператора). Встроенные функции исполняются быстрее, но могут занимать в памяти больше места, чем обычные функции, если только размер встроенных функций не является очень маленьким.
Ключевое слово ***inline*** является лишь рекомендацией компилятору, которая может быть проигнорирована. В этом случае функция будет скомпилирована как обычная. Такое может произойти, например, в том случае, если компилятор посчитает функцию слишком длинной.
В языке C, встраиваемые функции являются аналогом широко используемого макроса ***#define***.
Можно организовать функцию, имеющую аргументы, таким образом, чтоб вызывать ее, вообще не указывая при этом никаких аргументов. Однако для этого при объявлении функции необходимо задать значения ***аргументов по умолчанию***.
Если при вызове функции число переданных аргументов на единицу меньше, чем описано в прототипе, то компилятор считает, что отсутствует последний аргумент и установит его значение по умолчанию.
Обратите внимание, что опускать при вызове можно только аргументы, стоящие в конце списка при объявлении функции. Задание значений аргументов по умолчанию полезно в тех случаях, когда аргументы функции часто принимают какое-то одно значение. 
***Область видимости*** определяет, из каких частей программы возможен доступ к переменной, а 
***класс памяти*** — время, в течение которого переменная существует в памяти компьютера.
Переменные, имеющие ***локальную область видимости***, доступны внутри того блока, в котором они определены.
Переменные, имеющие ***область видимости файла***, доступны из любого места файла, в котором они определены.
***Блоком*** обычно считается код, заключенный в фигурные скобки.
Существует два класса памяти: ***automatic*** (автоматический) и ***static*** (статический).
У переменных, имеющих класс памяти ***automatic***, время жизни равно времени жизни функции, внутри которой они определены.
У переменных, имеющих класс памяти ***static***, время жизни равно времени жизни всей программы.
Статические локальные переменные используются в тех случаях, когда необходимо сохранить значение переменной в памяти после того, как выполнение функции будет завершено, или, другими словами, между вызовами функций.
Подобно тому как мы передавали в функцию аргументы с помощью ссылок, мы можем возвращать значение функции по
ссылке (Виртуальные функции) для избежания копирования больших объектов. Функция, возвращающая ссылку, интерпрети-
руется как переменная. С помощью ссылки вы не можете возвратить из функции константу.
В случае, если аргумент занимает много места в памяти, его передача по ссылке является гораздо более эффективной, поскольку в последнем случае в функцию передается не значение переменной, а только ее адрес.
Предположим, что вы используете ссылочный механизм только из соображений эффективности и при этом не хотите, чтобы функция имела свободный доступ к аргументу и изменяла его значение. Для того чтобы получить подобную гарантию, вы можете указать модификатор const перед соответствующим аргументом в прототипе функции.
Если вы желаете передать в функцию константную переменную с помощью ссылки, у вас не остается другого выбора, как использовать модификатор const в прототипе функции.

# **Глава 6**
# **Объекты и классы**
Объект является экземпляром класса, так же, как автомобиль является экземпляром колесного средства передвижения. 
Ключевой особенностью объектно-ориентированного программирования является возможность сокрытия данных. Этот термин понимается в том смысле, что данные заключены внутри класса и защищены от несанкционированного доступа функций, расположенных вне класса. Если необходимо защитить какиелибо данные, то их помещают внутрь класса с ключевым словом ***private***. Такие данные доступны только внутри класса. Данные, описанные с ключевым словом ***public***, напротив, доступны за пределами класса.
Сокрытие данных в нашем толковании означает ограждение данных от тех частей программы, которые не имеют необходимости использовать эти данные. В более узком смысле это означает сокрытие данных одного класса от другого класса. Сокрытие данных позволяет уберечь опытных программистов от своих собственных ошибок. Программисты могут сами создать средства доступа к закрытым данным, что значительно снижает вероятность случайного или некорректного доступа к ним.
***Данные***, содержащиеся внутри класса, называют данными-членами или ***полями класса***. Число полей класса, как и у структуры, теоретически может быть любым.
***Методы класса*** — это функции, входящие в состав класса.
Методы класса, определенные внутри класса, по умолчанию являются встраиваемыми. Функция, определенная вне класса, по умолчанию уже не является встраиваемой. Доступ к методам класса возможен только через конкретный объект этого класса.
Обратите внимание на то, что при определении класса не создаются никакие его объекты. Определение класса лишь задает вид будущего объекта, подобно тому, как определение структуры не выделяет память под структурные переменные, а лишь описывает их организацию. Все операции программа производит с объектами. Определение объекта похоже на определение переменной: оно означает выделение памяти, необходимой для хранения объекта.
Для того чтобы получить доступ к методу класса, необходимо использовать операцию точки (.) (операцию точки называют операцией доступа к члену класса).
Удобнее инициализировать поля объекта автоматически в момент его создания, а не явно вызывать в программе соответствующий метод. Такой способ инициализации реализуется с помощью особого метода класса, называемого конструктором. ***Конструктор*** — это метод класса, выполняющийся автоматически в момент создания объекта. При создании каждого объекта вызывается конструктор класса, присваивающий полям нулевое значение по-умолчанию. Имя конструктора в точности совпадает с именем класса. Таким образом, компилятор отличает конструкторы от других методов класса. У конструкторов не существует возвращаемого значения.
Counter()
{ count = 0; }
Такая форма записи не рекомендуется, несмотря на то, что она не содержит ошибок. 
Инициализация в нашем примере происходит следующим образом:
Counter() : count(0) { }
Список инициализации:
SomeClass() : m1(7), m2(33), m3(4) { }
Инициализация полей с помощью списка инициализации происходит до начала исполнения тела конструктора, что бывает важно.
Конструктор без параметров называется ***конструктором по умолчанию***. Если бы конструктор по умолчанию не создавался автоматически, то мы не смогли бы определять переменные классов, в которых отсутствует конструктор.
Если же для нас важно, какими значениями будут инициализироваться поля объекта класса, то нам следует явно определить конструктор.
Два явно определенных конструктора с одним и тем же именем является ***перегруженным***.
В примере ENGLCON метод add_dist() определен вне класса Distance(). Внутри определения класса содержится лишь прототип функции add_dist();
void Distance::add_dist(Distance dd1, Distance dd2)
:: - символ является знаком ***операции глобального разрешения***. Такая форма записи устанавливает взаимосвязь функции и класса, к которой относится эта функция.
Рассмотрим третий способ инициализации объекта, использующий значения полей уже существующего объекта. ***Копирующим конструктором по умолчанию***. Копирующий конструктор имеет единственный аргумент, являющийся объектом того же класса, что и конструктор.
Distance dist1(11, 6.25); // конструктор с двумя аргументами
Distance dist2(dist1);	// два конструктора с одним аргументом
Distance dist3 = dist1;
Мы инициализировали объект dist1 значением 11'-6.25" при помощи конструктора с двумя аргументами. Затем мы определяем еще два объекта класса Distance с именами dist2 и dist3, оба из которых инициализируются значением объекта dist1. Поскольку аргументом являлся объект того же класса, был вызван копирующий конструктор по умолчанию. Distance dist2(dist1) Действие копирующего конструктора по умолчанию сводится к копированию значений полей объекта dist1 в соответствующие поля объекта dist2. 
Идентичные действия для пары объектов dist1 и dist3 выполняются при помощи оператора Distance dist3 = dist1; Здесь, как и в предыдущем случае, вызывается конструктор копирования по умолчанию.
***Деструкторы*** - функция, автоматически вызываемая при уничтожении объекта. Деструктор имеет имя, совпадающее с именем конструктора и предваряющееся символом ~. Подобно конструкторам, деструкторы не возвращают значения и не имеют аргументов.
***Структуры*** предназначены для объединения данных, а ***классы*** — для объединения данных и функций. На самом деле, в большинстве ситуаций можно использовать структуры так же, как и классы. Формально ***разница между структурами и классами*** заключается лишь в том, что по умолчанию все члены класса являются скрытыми, а все члены структуры — открытыми.
Если поле данных класса описано с ключевым словом ***static***, то значение этого поля будет одинаковым для всех объектов данного класса.
Статические данные класса полезны в тех случаях, когда необходимо, чтобы все объекты включали в себя какое-либо одинаковое значение. Статическое поле по своим характеристикам схоже со статической переменной: оно видимо только внутри класса, но время его жизни совпадает со временем жизни программы. ***Определение статических полей*** класса происходит не так, как для обычных полей. Объявление поля находится внутри определения класса, а определение поля располагается вне класса и зачастую представляет собой определение глобальной переменной. Если бы определение статического поля класса находилось внутри класса, то это нарушило бы принцип, в соответствии с которым определение класса не должно быть связано с выделением памяти. Если вы объявите статическое поле класса, но забудете его определить, компилятор не выдаст предупреждающего сообщения.
В памяти компьютера каждый объект имеет свои собственные участки, хранящие значения полей этого объекта, но методы класса хранятся в памяти в единственном экземпляре.
***Константные методы класса***
Константные методы ***const*** отличаются тем, что не изменяют значений полей своего класса. Те методы, которые лишь считывают данные из поля класса, имеет смысл делать константными, поскольку у них нет необходимости изменять значения полей объектов класса. С помощью константных функций можно создавать и использовать константные объекты, как мы увидим позже.
***Константные аргументы методов***
Если необходимо передать аргумент в функцию ***по ссылке*** и в то же время ***защитить его от изменения функцией***, необходимо сделать этот аргумент константным при объявлении и определении функции.
***Константные объекты***
Если объект класса объявлен с модификатором ***const***, он становится недоступным для изменения. Это означает, что для такого объекта можно вызывать только константные методы.
const Distance football(300, 0);
Когда вы создаете класс, всегда является хорошим стилем объявлять константными функции, не изменяющие полей объектов класса. Это позволяет тому, кто использует данный класс, создавать константные объекты класса. Из этих объектов могут вызываться только константные функции.
Первым достоинством ***объектно-ориентированного программирования*** является то, что оно обеспечивает значительное сходство между объектами реального мира, моделируемыми программой, и объектами классов C++.

# **Глава 7**
# **Массивы и строки**
Массив - механизм группировки данных. Данные, сгруппированные в массиве, могут быть как основных типов, таких, как int или float, так и определенных пользователем типов, таких, как структуры или объекты. В массиве группируются однотипные данные. Доступ к элементам массива — по ***индексу***.
Для массива необходимо указать размер, который определяет, сколько элементов массив может содержать. Размер следует за именем и заключается в квадратные скобки int days_per_month[12]
Не нужно использовать размер массива, когда мы инициализируем все элементы массива, так как компилятор может его вычислить, подсчитав инициализированные переменные. Таким образом, мы можем записать
int days_per_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
Если инициализированы только несколько элементов, то оставшимся элементам будет присвоено значение 0. Если же инициализаций будет слишком много, то компилятор выдаст ошибку.
Массивы могут быть ***многомерными*** double sales[DISTRICTS][MONTHS];
Трехмерный массив — это массив массивов, которые состоят из массивов. Доступ к элементам массива осуществляется с использованием трех индексов: elem = dimen3[x][у][z];
cout << setiosflags(ios::fixed) << setiosflags(ios::showpoint) << setprecision(2) << setw(10) << fpn;
Флаг fixed предотвращает печать числа в экспоненциальной форме, например 3.45e3. 
Флаг showpoint определяет положение десятичной точки, даже если число не имеет дробной части: 123.00 вместо 123.
Для установки точности до двух знаков после запятой используйте метод setprecision с числом в качестве аргумента. 
Ширину поля, используя метод setw.
Массивы могут быть использованы как аргументы функций. В объявлениях функции массивы-аргументы представлены типом данных и размером. 
void display(double[DISTRICTS][MONTHS]);
Нa самом деле здесь есть один необязательный элемент. Следующее объявление работает так же:
void display(double[][MONTHS]);
Отсюда следует, что если мы объявили функцию с одномерным массивом в качестве аргумента, то нам не нужно указывать размер массива:
void somefunc(int elem[]);
При вызове функции в качестве аргумента используется только имя массива ***display(elem)***;
Имя elem в действительности представляет собой ***адрес массива в памяти***. Использование адресов для массивов-аргументов ***похоже на*** использование аргумента ***ссылки***, при котором значения элементов массива не дублируются (копируются) в функции. Вместо этого функция работает с оригинальным массивом, хотя ссылается на него, используя другое имя. Эта система используется для массивов, потому что они могут быть очень большими.
Однако ***адрес*** — это не то же самое, что и ссылка. С именем массива не используется амперсанд (&) при объявлении функции. Массивы передаются в функцию только с использованием их имени и функция работает при этом с оригиналом массива, а не с его копией.
Массивы могут содержать в себе не только данные основных типов, но и структуры. ***Массивы структур*** — это полезный тип данных, используемый в различных ситуациях.
Массивы могут быть использованы в качестве ***полей класса***. Давайте рассмотрим пример, стек. ***Стек*** работает как пружинное устройство, удерживающее патроны в магазине. Функции передают аргументы и хранят возвращаемые адреса в стеке.
Класс stack является примером важной возможности ООП; он используется для реализации контейнера или механизма для хранения данных. Стек может быть использован не только для этой цели. Он применяется в связных списках, очередях, группах и т. д.
Мы можем создать массив объектов.
Что случится если введется в массив большее число элементов, чем возможно ? В C++ нет проверки границ массива. Если программа поместит что-то за пределами массива, то компилятор и исполняемая программа протестовать не будут. Однако эти данные могут быть записаны поверх других данных или поверх самой программы. Это может послужить причиной странных эффектов или даже полного краха системы.
***Строки*** В C++ используются два вида строк: строка как массив символов типа ***char*** и строка как объект класса ***string***. В этом разделе мы опишем первый тип строк, строка — это массив элементов типа char. Тем не менее строки, созданные с помощью класса string, во многих ситуациях вытеснили строковый тип. Но строковый тип все еще используется по многим причинам. Во-первых, он используется во многих библиотечных функциях языка C. Во-вторых, он год за годом продолжает появляться в кодах. И в-третьих, для изучающих C++ строковый тип наиболее примитивен и поэтому легко понимается на начальном уровне.
***Строковые переменные***
Как и другие типы данных, строки могут быть ***переменными*** и ***константами***. char str[100];
Каждый символ занимает 1 байт памяти. Важная деталь, касающаяся строк, состоит в том, что они должны завершаться байтом, содержащим 0. Это часто представляют символьной константой \0, код которой в ASCII равен 0. Завершающий ноль называется нулевым символом.
В C++ нет встроенного механизма, защищающего программу от помещения элементов за пределы массива. Однако существует возможность ограничить при использовании операции >> количество символов, помещаемых в массив. 
cin >> setw(MAX) >> str; // ввод не более чем MAX-1 символов. Метод setw определяет максимальное количество символов, которое сможет принять буфер.
***Строковые константы*** Вы можете инициализировать строку постоянным значением при ее определении. 
char str[] = "Я памятник себе воздвиг нерукотворный.";
Операция >> считает пробел нулевым символом. Таким образом, он считывает строки, состоящие из одного слова, и что-либо, напечатанное после пробела, отбрасывается.
Для считывания строк, содержащих пробелы, мы используем другой метод — cin.get(). Этот синтаксис означает использовать метод get() класса stream для его объекта cin.
cin.ignore();
cin.get();
***Считывание нескольких строк*** Оказывается, что метод cin.get() может иметь третий аргумент, который пригодится нам в этой ситуации. Этот аргумент определяет символ, на котором метод завершает считывание строки. Установленным по умолчанию значением является'\n', но если вы вызовете метод с другим аргументом, то это значение заменится на введенный вами символ.
cin.get(str, MAX, '$');
***Копирование строк***
Функция strlen() определяет длину строки (сколько символов строка содержит). Мы используем длину строки для ограничения цикла for, чтобы скопировать нужное нам количество символов. Скопированная версия строки должна заканчиваться нулевым символом. Однако длина строки, возвращаемая функцией strlen(), не включает в себя нулевой символ. Мы могли скопировать один добавочный символ, но проще вставить нулевой символ явно.
***Копирование строк более простым способом***
Конечно, вам не обязательно использовать цикл for для копирования строк. Для этого существует библиотечная функция strcpy(). Заметим, что первым аргументом этой функции является строка, куда будут копироваться данные:
strcpy(destination, source);
Порядок записи справа налево напоминает формат обыкновенного присваивания: переменная справа копируется в переменную слева. Похожая функция strncpy() принимает еще третий аргумент, определяющий максимальное количество символов, которое может быть скопировано.
При использовании строкового типа в C++ вы не можете использовать выражение strDest = strSrc; для установки равенства одной строки другой. В стандартном классе C++ string эта проблема решена.
Альтернативный формат вызова этого конструктора, одноаргументным конструктором, будет таким:
String s1 = "С Новым годом! ";
***Стандартный класс string языка C++***
Вам не нужно заботиться о создании массива нужного размера для содержания строковых переменных. Класс string берет на себя ответственность за управление памятью. Этот класс позволяет использовать перегруженные операции, объединять строковые объекты, используя операцию +: ***s3 = s1 + s2***; Этот класс более эффективен и безопасен в использовании, чем строковый тип.
Определить объект класса string можно различными способами: использовать конструктор без аргументов, создающий пустую строку и конструктор с одним аргументом, где аргумент является строковой константой, символы ограничены двойными кавычками.
string s1("Рыба");
string s2 = "Мясо";
string s3;
метод класса string ***swap()*** — меняет местами значения двух строковых объектов. Он вызывается для одного объекта, в то время как другой объект является его аргументом bs1.swap(bs2);
Операции << и >> перегружены для использования с объектами класса string, метод getline() принимает ввод, который может содержать пробелы или несколько строк.
Программа считывает имя пользователя, которое, возможно, содержит внутренние пробелы, используя метод ***getline()***. Эта функция похожа на метод get(), используемый для строкового типа, но это не метод класса. Первым аргументом является потоковый объект, из которого будет приниматься ввод (cin), а второй аргумент — это объект класса string, куда будет помещен текст.
Класс string включает в себя различные методы для поиска строк и фрагментов строк в объектах класса string. Метод ***find()*** предназначен для поиска строки, используемой в качестве аргумента, в строке, для которой был вызван метод. Метод ***find_first_of()*** предназначен для поиска любого символа из группы и возвращает позицию первого найденного. Похожий метод ***find_first_not_of()*** ищет первый символ в строке, который не
входит в определенную группу символов. Функция ***rfind()***, переворачивающая строку, ***find_last_of()***, ищущая последний символ, совпадающий с группой заданных символов и ***find_last_not_of()***. Все эти функции возвращают -1, если цель не найдена.
Существуют различные пути модификации объектов класса string. Метод ***erase()*** удаляет фрагмент из строки. Его первым аргументом является позиция первого символа фрагмента, а вторым — длина фрагмента. Метод ***replace()*** заменяет часть строки на другую строку. Его первым аргументом является позиция начала замены, вторым — количество символов исходной строки, которое должно быть заменено, а третьим аргументом является строка для замены. Метод ***insert()*** вставляет строку, определенную во втором аргументе, на место, определенное в первом аргументе. Метод ***size()*** возвращает количество символов в объекте класса string. Метод ***append()*** ставит знаки в конце. В этой версии метода первый аргумент — это количество символов, которое будет добавлено, а второй аргумент — это символы, которые будут добавлены.
Можно использовать перегруженные операции или метод ***compare()*** для сравнения объектов класса string. Задача состоит в том, чтобы определить, являются ли строки идентичными или какая из них предшествует другой в алфавитном порядке. 
userName.compare(0, 2, aName, 0, 2);
Аргументами метода ***compare()*** являются начальная позиция userName, число символов, которые надо сравнить, строка, используемая для сравнения (aName), а также начальная позиция и количество символов в строке aName.
Метод ***substr()*** возвращает фрагмент строки, для которой метод был вызван. Его первый аргумент — это позиция фрагмента, а второй — количество символов.
Доступ к отдельным символам объектов класса string вы можете получить разными способами. Вы можете использовать перегруженную операцию ***[]***, которая позволяет рассматривать объект класса string как массив. Однако операция [] не предупредит вас, если вы попытаетесь получить доступ к символу, лежащему за пределами массива в отличии от метода ***at()***.
Метод ***copy()*** для копирования объекта класса string в массив типа char, эффективно преобразовывая его в строковый тип.
Метод ***length()*** класса string возвращает то же число, что и метод ***size()***.
Можно также преобразовать объект класса string к строковому типу, используя методы ***c_str()*** или ***data()***.
Метод ***capacity()*** возвращает действительное количество занятой памяти. Вы можете добавлять символы в строку, не добавляя памяти в нее до тех пор, пока этот лимит не будет исчерпан.
Метод ***max_size()*** возвращает максимально возможный размер объекта класса string. Это количество будет на три байта меньше, чем максимальное значение переменной типа int в вашей системе.
Объекты класса string не заканчиваются ***нулевым символом***, как это происходит в строковом типе. Строковый тип представляет собой массив элементов типа char. Последний символ такой строки должен быть нулевым, '\0'.

# **Глава 8**
# **Перегрузка операций**
Перегрузка операций — это одна из самых захватывающих возможностей ООП. Она может превратить сложный и малопонятный листинг программы в интуитивно понятный. Например, строки d3.addobjects(d1, d2); похожие, но одинаково непонятные
d3 = d1.addobjects(d2); можно заменить на более читаемую 
d3 = d1 + d2;
Довольно непривлекательный термин «перегрузка операций» дается обычным операциям C++, таким, как +, *, <= или +=, в случае их применения с определенными пользователем типами данных.
а = b + с; работают только с основными типами данных, такими, как int или float, и попытка использования обычных операторов, когда a, b и с являются объектами определенного пользователем класса, приведет к протестам компилятора.
Как использовать обычные операции с определенными пользователями типами? В этом объявлении использовано ключевое слово ***operator*** для перегрузки операции ++:
***void operator++()***
Сначала пишут возвращаемый тип (в нашем случае void), затем ключевое слово operator, затем саму операцию (++) и наконец список аргументов, заключенный в скобки (здесь он пуст). Такой синтаксис говорит компилятору о том, что  если операнд принадлежит классу Counter, то нужно вызывать функцию с таким именем, встретив в тексте программы операцию ++.
Вы можете его выявить, если используете в функции main() строку, похожую на эту:
c1 = ++c2;
Компилятор будет протестовать потому, что мы определили тип void для возвращаемого значения функции operator++(). А в нашем выражении присваивания будет запрошена переменная типа Counter. То-есть компилятор запросит значение переменной c2, после того как она будет обработана операцией ++, и присвоит ее значение переменной c1.
Counter operator++() {
	++count;
	Counter temp;
	temp.count = count;
	return temp;
}
***Постфиксные операции***
Теперь у нас есть два типа объявления функции operator++. С одной из них, для префиксной операции, мы уже были знакомы ранее:
Counter operator++();
Для реализации постфиксной записи операции ++ используем новую функцию:
Counter operator++(int);
Различие между этими функциями только в том, что в скобках стоит int. Здесь int не играет роли аргумента и не означает целое число. Это просто сигнал для компилятора, чтобы использовалась постфиксная версия операции. Разработчики C++ нашли полезным повторное использование существующих операций и ключевых слов; в данном случае int предназначена также и для обозначения постфиксной операции.
***Перегрузка бинарных операций***
Бинарные операции могут быть перегружены так же, как и унарные операции.
***Арифметические операции***
Используя перегрузку операции +, мы можем отказаться от dist3.add_dist(dist1, dist2); выражения и воспользоваться таким: dist3 = dist1 + dist2;
// сложение двух длин
Distance operator+(Distance) const;
Эта операция возвращает значение типа Distance и принимает один аргумент типа Distance. Но какой из объектов используется в качестве аргумента этой операции — dist1 или dist2?
Существует правило: объект, стоящий с левой стороны операции (в нашем случае dist1), вызывает функцию оператора. Объект, стоящий справа от знака операции (dist2), должен быть передан в функцию в качестве аргумента. Операция возвращает значение, которое мы затем используем для своих нужд. В нашем случае мы присваиваем его объекту dist3. В функции ***operator+()*** к левому операнду мы имеем прямой доступ, используя feet и inches, так как это объект, вызывающий функцию. К правому операнду мы имеем доступ как к аргументу функции, то есть как d2.feet и d2.inches.
Мы можем обобщить изложенное выше и сказать, что перегруженной операции всегда требуется количество аргументов на один меньшее, чем количество операндов, так как один из операндов является объектом, вызывающим функцию. Поэтому для унарных операций не нужны аргументы (это правило неверно для функции и операторов, являющихся дружественными для класса ГЛАВА 11).
***Объединение строк***
Операция + не может быть использована для объединения строк: str3 = str1 + str2; где str1, str2 и str3 — строковые переменные (массивы типа char). Однако если мы будем использовать свой собственный класс String из программы STROBJ главы 6, то мы сможем перегрузить операцию + для объединения строк. Это же делает и стандартный класс string в C++.
Перегрузка операции + в этом случае похожа на то, что мы делали ранее. Объявление: ***String operator+(String ss)*** показывает, что функция operator+() принимает один аргумент типа String и возвращает объект того же типа. При объединении строк с помощью функции operator+() создается временный объект типа String, в него копируется строка объекта, для которого вызвана функция. Затем, используя библиотечную функцию strcat(), мы присоединяем к ней строку из объекта аргумента и возвращаем полученную во временном объекте строку. 
Заметим, что мы не можем использовать return String(string); такой подход, где создается безымянный временный объект типа String, так как нам нужен доступ к временному объекту не только для его инициализации, но и для присоединения к нему строки аргумента.
***Операции сравнения***
bool operator<(Distance) const;
Подход, используемый для функции ***operator<()***, похож на перегрузку операции +, за исключением того, что здесь функция operator<() имеет возвращаемое значение типа bool. Возвращаемым значением может быть false или true, в зависимости от результата сравнения двух интервалов. При сравнении мы конвертируем оба интервала в значения футов с плавающей точкой и затем сравниваем их, используя обычную операцию <.
***Сравнение строк***
bool operator==(String ss) const;
Функция ***operator==()*** использует библиотечную функцию strcmp() для сравнения двух строк. Эта функция возвращает 0, если строки равны, отрицательное число, если первая строка меньше второй, и положительное число, если первая строка больше второй строки. Здесь «меньше чем» и «больше чем» использованы в их лексикографическом смысле для определения того, что стоит раньше в алфавитном списке — первая строка или вторая.
Другие операции сравнения, такие, как < и >, могут быть также использованы для сравнения лексикографического значения строк. Или, что то же самое, операторы сравнения могут быть переопределены для сравнения длины строк. Так как вы можете сами определять, для чего будет использоваться операция, то вы можете использовать любое подходящее для вашей ситуации определение.
***Операции арифметического присваивания***
dist1 += dist2;
Заметим, что существует различие между функцией ***operator+=()***, используемой здесь, и функцией operator+() из программы ENGLPLUS. В функции operator+() создается новый объект типа Distance. В функции operator+=() программы ENGLPLEQ объектом, принимающим значение суммы, является объект, вызывающий функцию operator+=().
Но если мы захотим использовать эту операцию в более сложных выражениях, таких, как:
dist3 = dist1 += dist2;
то в этом случае нам понадобится возвращаемое значение. Мы можем ввести его, записав в конце определения функции operator+=() строку:
return Distance(feet, inches);
***Операция индексации массива ([])***
Например, если вам понадобится создать «безопасный массив», в котором заложена автоматическая проверка используемого для доступа к массиву индекса элемента. Она будет проверять, находитесь ли вы в границах массива. (Вы можете также использовать класс vector, описанный в главе 15 «Стандартная библиотека шаблонов (STL)».)
***Перегруженная операция индексации должна возвращать свои значения по ссылке.*** Чтобы показать, почему это так, мы рассмотрим три программы, которые реализуют «безопасный» массив, каждая при этом использует свой подход для вставки и считывания элементов массива:
♦ два отдельных метода put() и get(); - Безопасность массива реализована с помощью вывода сообщения об ошибке при попытке использования индекса, не входящего в границы массива.
♦ метод access(), использующий возвращение по ссылке; - Это использование одного метода для ввода и вывода элементов массива в общем случае немного более удобно, чем использование отдельных методов, на одно имя меньше.
♦ перегруженная операция [], ***int& operator[](int n)***, использующая возвращение по ссылке. Так как эта операция обычно используется слева от знака равно, наша перегруженная функция должна возвращать свое значение по ссылке
***Преобразование типов***
Обычно если значение одного объекта присваивается другому объекту того же типа, то значения всех переменных объекта просто копируются в новый объект. Компилятору не нужны специальные инструкции, чтобы использовать операцию = для определенных пользователем типов, таких, как объекты класса Distance.
Но что же случится, если с разных сторон знака равно будут стоять переменные разных типов? Однако философия C++ (и С) — это гибкость, предоставленная возможностью преобразования, которая перевешивает недостатки.
***Преобразования основных типов в основные типы***
intvar = floatvar;
Конечно, существует множество таких преобразований: из float в double, из char во float и т. д. Каждое такое преобразование имеет свою процедуру, встроенную в компилятор, которая вызывается в зависимости от типов переменных, стоящих с обеих сторон знака равно. Мы говорим, что преобразования ***неявные***, так как они не отражены в листинге.
Иногда мы хотим принудительно заставить компилятор преобразовать один тип в другой. Для этого используется оператор ***cast***. Например, для преобразования float в int мы можем записать следующее выражение:
intvar = static_cast<int>(floatvar); - ***Явное преобразование !***
***Преобразования объектов в основные типы и наоборот***
Если нам нужно осуществить преобразование определенных пользователем типов в основные типы, то мы не можем положиться на встроенные функции, так как компилятору не известно об определенных пользователем типах ничего, кроме того, что мы скажем ему сами.
operator float() const // оператор перевода для получения метров из футов
***Преобразование основного типа в тип, определенный пользователем.***
operator float() const {
	float fracfeet = inches / 12;		// переводим дюймы в футы
	fracfeet += static_cast<float>(feet); 	// добавляем целые футы
	return fracfeet / MTF;			// переводим в метры
}
-----------------------
class bMoney {
    long double money;
    char streams[MAXSTR] = "$";
public:
    bMoney();
    bMoney(char s[]);
    bMoney(long double); 	// неявный конструктор преобразования long double в bMoney 
    bMoney(long double) { 	// неявный конструктор преобразования long double в bMoney 
    	
    }
}
***От основного к определенному пользователем***
Для перехода от основного типа — в нашем случае float — к определенному пользователем типу, такому, как Distance, мы используем конструктор с одним аргументом.
Distance(float meters) {
	float fltfeet = MTF * meters;
	feet = int(fltfeet);
	inches = 12 * (fltfeet - feet);
}
***От определенного пользователем к основному***
Здесь вся хитрость в том, чтобы создать что-то, называемое операцией преобразования.
operator float() {
	float fracfeet = inches / 12;
	fracfeet += float(feet);
	return fracfeet / MTF;
}
***Преобразования строк в объекты класса string и наоборот***
operator char*() { return str; }        // перевод строки к обычному типу
String s2 = "Мы победим!";
Звездочка в этом выражении означает указатель на. Это означает указатель на char, что почти то же, что и массив типа char. То есть запись char* — почти то же, что char[]. Это просто другой способ объявления переменной строкового типа.
Оператор преобразования используется компилятором в строке cout << static_cast<char*>(s2);
Здесь s2 — переменная, использованная в качестве аргумента для перегруженной операции <<. Так как операции << ничего не известно об определенном пользователем типе String, то компилятор будет пытаться преобразовать переменную s2 к одному из известных ему типов. Мы определяем тип, к которому хотим преобразовать переменную, с помощью оператора static_cast для char*.
Оператор ищет преобразование от типа String к строковому типу и, найдя нашу функцию char*(), использует ее для генерации строки, которая затем будет выведена через операцию <<.
Пример демонстрирует, что преобразование типов происходит автоматически не только в выражениях присваивания, но и в других подходящих местах, таких, как пересылка аргументов операциям (например, <<) или функциям.
***Преобразования объектов классов в объекты других классов***
Для них применяются те же два метода преобразования, что и для преобразований между основными типами и объектами определенных пользователем классов. То есть вы можете использовать ***конструктор с одним аргументом*** или ***операцию преобразования***.
objecta = objectb;
где objecta — объект класса A, a objectb — объект класса B. Где же расположить функцию преобразования, в классе А (это класс назначения, так как objecta получает значение) или в классе В? Мы рассмотрим оба варианта.
В нашей первой программе мы рассмотрим случай, когда ***функция преобразования расположена в исходном классе*** - 
time24::operator time12() const {
...
   return time12(pm, hrs12, roundMins);
}
Эта функция преобразует вызывающий ее объект в объект класса time12 и возвращает функции main() объект, который будет затем присвоен переменной t12.
Если ***функция преобразования находится в классе назначения***, то в этой ситуации используется конструктор с одним аргументом. Однако все усложняется тем фактом, что конструктор класса назначения должен иметь доступ к данным исходного класса для выполнения преобразования. Поля класса time24 — hours, minutes и seconds — объявлены как private, поэтому мы должны написать специальные методы в классе time24, которые будут позволять к ним прямой доступ.
В классе time12 - time12(time24);	// конструктор с 1 аргументом
time12::time12(time24 t24) {
...
}
Результат работы программы будет таким же. Все различия находятся в коде, где предпочтение при выполнении отдается конструктору объекта назначения, а не операции преобразования исходного объекта.
-----
Если вы покупаете библиотеку классов, то вы можете не иметь доступа к ее исходным файлам. Если вы будете использовать объект такого класса в качестве исходного в преобразовании, то вы сможете получить доступ только к классу назначения, поэтому вам нужно будет использовать конструктор с одним аргументом. Если же объект назначения принадлежит библиотечному классу, то вы должны использовать операцию преобразования в исходном классе.
Обычно два класса объединены, если объект одного из классов вызывает метод (операцию) объекта другого класса. Объединение возникает также, если атрибут одного из классов является объектом другого класса.
***Избегайте выполнения одного преобразования с помощью нескольких разных способов.***
Следующие операции не могут быть перегружены: операция доступа к членам структуры или класса (.), операция разрешения (::) и операция условия (?:). А также операция (->). Кроме того, нельзя создавать новые операции (например, нельзя определить новую операцию возведения в степень **, которая есть в некоторых языках) и пытаться их перегрузить; перегружать можно только существующие операции.
Ключевое слово ***explicit*** относится к преобразованию типов, a ***mutable*** предназначено для более хитрых целей.
Могут появляться другие преобразования, которые вы не хотите делать. И вы активно препятствуете их осуществлению, чтобы предотвратить неприятные сюрпризы. Легко предотвратить выполнение операции преобразования: вы можете просто не определять этой операции. Но с конструкторами не все так просто. Вам может понадобиться сконструировать объекты с использованием одного значения другого типа, при этом вы не хотите, чтобы осуществилось скрытое преобразование с помощью конструктора с одним аргументом. Что же делать?
В стандарт языка C++ включено ключевое слово ***explicit***, предназначенное для решения этой проблемы. Оно просто помещается перед объявлением конструктора с одним аргументом.
// explicit ERROR Distance dist1 = 2.35F;
Иногда случаются ситуации, когда вы хотите создать объект-константу, имеющий определенное поле, которое нужно будет изменять, несмотря на то, что сам объект является константой.
Предположим, мы хотим иметь возможность создать константные полосы прокрутки, все атрибуты которых остаются неизменными, за исключением их владельца. Тогда нам и пригодится ключевое слово ***mutable***.
Атрибут size из данных объекта класса scrollbar не может быть изменен в объекте-константе. Однако атрибут owner может быть изменен даже если объект — константа. Для того чтобы позволить это, используем ключевое слово mutable.
***Таблица Преобразование типов***
			Процедура в классе назначения		Процедура в исходном классе
Основной в основной	(Встроенные операции преобразования)
Основной к классу	Конструктор				N/A
Класс в основной	N/A					Операция преобразования
Класс в класс		Конструктор				Операция преобразования

# **Глава 9**
# **Наследование**
Наиболее значимой после классов возможностью ООП является наследование. Это процесс создания новых классов, называемых ***наследниками или производными классами***, из уже существующих или базовых классов.
Выигрыш от него состоит в том, что наследование позволяет использовать существующий код несколько раз.
Программист может использовать классы, созданные кем-то другим, без модификации кода, просто создавая производные классы, подходящие для частной ситуации.
class Counter { 			// базовый класс
protected:
    	unsigned int count;     // счетчик
	...
};
class CountDn : public Counter {    	// производный класс
public:
    	Counter operator--();
    	...
};
CountDn наследует все возможности класса Counter: конструктор и методы. Если мы не определили конструктор производного класса, то будет использоваться подходящий конструктор базового класса. Компилятор ищет сначала методы в производном классе, не найдя в базовом классе.
В программе COUNTEN переменная counter имеет другой спецификатор доступа: ***protected***. Но при использовании объекта, объявленного в программе, можно получить доступ только к данным со спецификатором public.
Однако при использовании наследования у нас появляется еще ряд добавочных возможностей. Возникает вопрос, могут ли методы производного класса иметь доступ к членам базового класса? Может ли operator--() класса CountDn иметь доступ к полю count класса Counter? Методы производного класса имеют доступ к членам базового класса, если они имеют спецификатор доступа ***public или protected***. К членам, объявленным как ***private***, доступа нет.
Мы не хотим объявлять поле count как public, так как это разрешит доступ к ней из любой функции программы, уничтожив возможность сокрытия данных.
Любой программист сможет получить доступ к членам классов, объявленным как protected, просто создавая производные классы. Это делает члены, объявленные как protected, значительно менее защищенными, чем объявленные как private. Чтобы избежать порчи данных, часто приходится разрешать доступ производным классам только к тем методам базового класса, которые объявлены как public.
Заметим также, что наследование не работает в обратном направлении. Базовому классу и его объектам недоступны производные классы. В нашем случае это означает, что объекты класса Counter, такие, как c2, не могут использовать метод operator--() класса CountDn.
CountDn c2(10); - ERROR
class CountDn : public Counter {    // производный класс
public:
    CountDn(int c) : Counter(c) {}
...
};
***Перегрузка функций***
Мы можем определять для производного класса методы, имеющие такие же имена, как и у методов базового класса. В этом случае имеет место перегрузка функций. Такая возможность может понадобиться, если для объектов базового и производного классов в вашей программе используются одинаковые вызовы.
Для исправления этих дефектов мы создадим новый класс Stack2, производный от Stack. И в родительском и в дочернем созданы методы с одинаковым названием. Как же компилятор поймет, какой из двух методов push() вызвать? 
Существует правило: если один и тот же метод существует и в базовом, и в производном классе, то будет выполнен метод производного класса. (Это верно для объектов производного класса. Объектам базового класса ничего не известно о производном классе, поэтому они всегда пользуются методами базового класса.)
В этом случае мы говорим, что метод производного класса ***перегружает метод базового класса***.
Как же методы push() и pop() класса Stack2 получают доступ к методам push() и pop() класса Stack? Они используют операцию разрешения :: следующим образом: Stack::push(var) и return Stack::pop();
С++ разработан для того, чтобы создание производных классов было эффективным. Мы легко можем использовать лишь части базового класса: данные, конструкторы или методы, затем добавить нужные нам возможности и создать новый улучшенный класс.
В наших примерах мы использовали объявление типа: class manager : public employee
Ключевое слово ***public*** определяет, что объект производного класса может иметь доступ к ***методам*** базового класса, объявленным как ***public***.
При использовании ***private*** для объектов производного класса нет доступа к методам базового класса, объявленным как public. Поскольку для объектов нет доступа к членам базового класса, объявленным как private или protected, то результатом будет то, что для объектов производных классов не будет доступа ни к одному из членов базового класса.
Объекты общего наследника класса B имеют доступ к членам класса A, объявленным как public или protected, а объекты частного наследника класса C имеют доступ только к членам, объявленным как public. Если не указывать спецификатор доступа при создании класса, то будет использован спецификатор private.
В случае, когда объект производного класса предоставляет доступ как к общим методам базового класса, так и к более специализированным методам своего класса, имеет смысл воспользоваться общим наследованием. Однако в некоторых ситуациях производный класс создается для полной модификации действий базового класса, скрывая или изменяя первоначальный его вид.
Производные классы могут являться базовыми классами для других производных классов.
class A { };
class В : public A { };
class C : public В { };
Результатом иерархии классов является обобщение схожих характеристик. Чем более общим является класс, тем выше он находится в схеме.
Класс может быть производным не только от одного базового класса, а и от многих. Этот случай называется ***множественным наследованием.***
class A {};
class В {};
class C : public A, public В {};
В определенных ситуациях могут появиться некоторые проблемы. Допустим, что в обоих базовых классах существуют методы с одинаковыми именами, а в производном классе метода с таким именем нет. Как в этом случае объект производного класса определит, какой из методов базовых классов выбрать?
Проблема решается путем использования оператора разрешения, определяющего класс, в котором находится метод. Таким образом,
ObjC.A::show();
направляет нас к версии метода show(), принадлежащей классу A, а
objC.B::show();
направляет нас к методу, принадлежащему классу B, Б. Страуструп называет это ***устранением неоднозначности***.
Другой вид ***неопределенности*** появляется, если мы создаем производный класс от двух базовых классов, которые, в свою очередь, являются производными одного класса. Это создает дерево наследования в форме ромба. Существует множество вариаций этой проблемы, поэтому многие эксперты советуют избегать множественного наследования.
Рассмотрим случай, когда объект класса A является атрибутом класса B:
class A { };
class В {
	A objA;
};
В ООП ***включение*** появляется, когда один объект является атрибутом другого объекта. Включение имеет копии классов.
***Композиция*** — это более сложная форма объединения. Она обладает всеми его свойствами, но имеет еще и такие, как:
***♦*** часть может принадлежать только одному целому;
***♦*** время жизни части то же, что и целого.
Если включение — это взаимоотношение типа ***«имеет»***, то композиция — это взаимоотношение типа ***«состоит из»***.
***♦***Класс, называемый ***производным классом***, может наследовать возможности другого класса, называемого ***базовым классом***. При этом в производном классе могут быть свои собственные возможности, так как он является более специализированной версией базового класса.
***♦***К полям и методам базового класса, объявленным как protected, могут иметь доступ только методы производного класса. Объекты внешних классов, включая сам производный класс, в этом случае доступа к базовому классу не имеют. Объекты общего производного класса имеют доступ к членам базового класса, объявленным как public, а объекты частного производного класса доступа к ним не имеют.
***♦***Класс может быть производным более чем одного базового класса. Этот случай называется ***множественным наследованием***.

# **Глава 10**
# **Указатели**
Для чего нужны указатели? Вот наиболее частые примеры их использования:
	♦ доступ к элементам массива;
	♦ передача аргументов в функцию, от которой требуется изменить эти аргументы;
	♦ передача в функции массивов и строковых переменных;
	♦ выделение памяти;
	♦ создание сложных структур, таких, как связный список.
В некоторых ситуациях указатели являются необходимым инструментом увеличения эффективности программ на языке C++. Например создание таких структур данных, как связные списки или бинарные деревья. Кроме того, виртуальные функции, операция new, указатель this, требуют использования указателей.
Начать нужно с того, что каждый байт памяти компьютера имеет адрес. ***Адреса*** — это те же числа, начинаются с 0, а затем возрастают — 1, 2, 3 и т. д. Если у нас есть 1 Мбайт памяти, то наибольшим адресом будет число 1 048 575. Каждая переменная и каждая функция нашей программы начинается с какого-либо конкретного адреса.
Мы можем получить адрес переменной, используя ***операцию получения адреса &***.
Адреса расположены в убывающем порядке, потому что локальные переменные хранятся в стеке, где адреса располагаются по убыванию. Если же использовать глобальные переменные, то их адреса располагаются в порядке возрастания, так как глобальные переменные хранятся в куче, где адреса располагаются по возрастанию.
Нам необходимы переменные, хранящие значение адреса. Нам знакомы переменные, хранящие знаки, числа с плавающей точкой, целые и т. д. Адреса хранятся точно так же. Переменная, содержащая в себе значение адреса, называется ***переменной-указателем*** или просто ***указателем***.
Переменная-указатель int* ptr;
Звездочка означает указатель на. Таким образом, в этой строке определена переменная ptr как указатель на int, то есть эта переменная может содержать в себе адрес переменной типа int.
Проблема в том, что компилятору нужны сведения о том, какого именно типа, переменная, на которую указывает указатель.
Нужно заметить, что общепринято определение указателя с помощью звездочки, записываемой перед именем переменной, а не сразу после названия типа ***char *charptr***;
char* ptr1, * ptr2, * ptr3; // три переменных указателя
Неинициализированный указатель может привести к краху системы, его очень тяжело выявить при отладке программы, так как компилятор не выдает предупреждения о подобных ошибках. Поэтому всегда важно убедиться, что каждому указателю перед его использованием было присвоено значение.
int* ptr; 		// указатель на целое
ptr = &var1;		// помещаем в ptr адрес переменной var1
cout << *ptr << endl; 	// показываем содержимое переменной через указатель
cout << ptr << endl; 	// показываем адрес переменной
Звездочка, стоящая перед именем переменной, как в выражении *ptr, называется ***операцией разыменования***. Эта запись означает: ***взять значение переменной, на которую указывает указатель.***
Операция разыменования ***предшествует*** имени переменной и означает ***значение, находящееся в переменной, на которую указывает указатель.*** Звездочка же в объявлении указателя означает ***указатель на.***
int* ptr; 	// обьявление: указатель на int
*ptr = 37; 	// разыменование: значение переменной, адресованной через ptr
Доступ к значению переменной, хранящейся по адресу, с использованием операции разыменования называется ***непрямым доступом*** или ***разыменованием указателя***.
int v; 		// определим переменную v типа int
int* р; 	// определим переменную типа указатель на int
р = &v; 	// присвоим переменной р значение адреса переменной v
v = 3; 		// присвоим v значение 3
*р = 3; 	// сделаем то же самое, но через указатель
***Указатель на void***
float flovar = 98.6;
int* ptrint = &flovar; // Так нельзя; типы int* и float* несовместимы
Однако есть одно исключение. Существует тип указателя, который может указывать на любой тип данных. Он называется указателем на void:
void* ptr; // указатель, который может указывать на любой тип данных
Такие указатели предназначены для использования в определенных случаях, например передача указателей в функции, которые работают независимо от типа данных, на который указывает указатель.
Если вам по некоторым причинам необходимо присвоить одному типу указателя другой тип, то вы можете использовать функцию reinterpret_cast.
ptrint = reinterpret_cast<int*>(&flovar);
***Указатели и массивы***
Необычно то, что доступ к элементам массива можно получить как используя операции с массивами, так и используя указатели.
int intarray[5] = { 31, 54, 77, 52, 93 };
cout << *(intarray + j) << endl;
Имя массива является его адресом. Таким образом, выражение intarray + j — это адрес чего-то в массиве. Вы можете ожидать, что intarray + З будет означать 3 байта массива intarray. Но три байта в этом массиве — середина второго элемента, что не очень полезно для нас. Мы хотим получить четвертый элемент массива, а не его четвертый байт.
Видя выражение intarray + 3, компилятор интерпретирует его как адрес четвертого элемента массива, а не четвертого байта. Но нам необходимо значение четвертого элемента, а не его адрес. Для его получения мы используем операцию разыменования (*).
Компилятору необходимо знать, на переменные какого типа указывает указатель, чтобы осуществлять правильный доступ к элементам массива.
***Указатели-константы и указатели-переменные***
Можем ли мы записать *(intarray++)?
Сделать так мы не можем, поскольку нельзя изменять константы. Выражение intarray является адресом в памяти, где ваш массив будет храниться до окончания работы программы, поэтому intarray — это указатель константы. Это то же, что 7++;
int intarray[5] = { 31, 54, 77, 52, 93 };
int* ptrint;
ptrint = intarray;		// пусть он указывает на наш массив
cout << *(ptrint++) << endl; 	// 54
переменная ptrint не является константой, то мы можем ее увеличивать.
***Указатели и функции***
void centimize(double *);
double var = 10.0;	// значение переменной var равно 10 (дюймов)
centimize(&var);
void centimize(double * ptrd) {
	*ptrd *= 2.54;	// *ptrd — это то же самое, что и var
}
****В качестве аргумента передает адрес, а не сама перменная как по ссылке. По значению передается копия.****
Передача указателя в функцию в качестве аргумента в некоторых случаях похожа на передачу по ссылке. Они обе позволяют переменной вызывающей программы быть измененной в функции. Однако их механизмы различны. Ссылка — это псевдоним переменной, а указатель — это адрес переменной.
***Передача массивов***
double varray[MAX] = { 10.0, 43.1, 95.9, 58.7, 87.3 };
centimizeMas(varray);           // передача по указателю
void centimize(double * ptrd) {
	for(int j = 0; j < MAX; j++)
		*ptrd++ *= 2.54;
}
При передаче массива по значению это выглядело бы так:
void centimize(double[]);
Записи double * и double[] эквивалентны, но синтаксис указателей используется чаще. Так как имя массива является его адресом, то нам нет надобности использовать операцию взятия адреса & при вызове функции: centimize(varray); // передается адрес массива
Как узнать, что в выражении *ptrd++ увеличивается указатель, а не его содержимое? Как компилятор интерпретирует это выражение: как *(ptrd++), что нам и нужно, или как (*ptrd)++? Здесь * и ++ имеют одинаковый приоритет. Однако операции одинакового приоритета различаются еще и другим способом: ***ассоциативностью***.
***Ассоциативность*** определяет, как компилятор начнет выполнять операции, справа или слева. В группе операций, имеющих правую ассоциативность, компилятор выполняет сначала операцию, стоящую справа. Унарные операции * и ++ имеют правую ассоциативность, по-этому наше выражение интерпретируется как *(ptrd++) и увеличивает указатель, а не то, на что он указывает.
***Указатели на строки***
Доступ через указатели может быть применен к элементам строки так же, как и к элементам массива.
char str1[] = "Определение через массив";
char* str2 = "Определение через указатель";
Во многих случаях эти два способа определения строк эквивалентны. Вы можете распечатать обе строки, используя их как аргументы функций. Но есть небольшое различие: str1 — это адрес, то есть указатель-константа, a str2 — указатель-переменная. Поэтому str2 может изменять свое значение, a str1 нет.
Строка, определенная как указатель, гораздо более гибка, чем строка, определенная как массив. (Может поэтому чаще всего видел const char *)
***Строки как аргументы функций***
char str[] = "У бездельников всегда есть свободное время.";
dispstr(str);
///////////////////////////////////////////////////////////
void dispstr(char* ps) {
	while(*ps) 	// пока не встретим конец строки
		cout << *ps++; // будем посимвольно выводить ее на экран
}
***Копирование строк с использованием указателей***
char* str1 = "Поспешишь - людей насмешишь!";
char str2[80];	// пустая строка
copystr(str2, str1);
void copystr(char* dest, const char* src) {
	while(*src) 	// пока не встретим конец строки
		*dest++ = *src++; 	// копируем ее
		*dest = '\0';		// заканчиваем строку
}
Значение src помещается по адресу, на который указывает dest. Затем оба указателя увеличиваются и на следующей итерации передается следующий символ.
***Модификатор const и указатели***
Модификатора const при объявлении указателя может сбивать с толку, потому что это может означать один из двух вариантов в зависимости от его расположения. 
const int* cptrInt; // указатель на константу
int* const ptrcInt; // константный указатель
Используя первый вариант объявления указателя, вы не можете изменять значение переменной, на которую указывает указатель cptrInt, но можете изменять значение самого указателя cptrInt. Во втором варианте вы не сможете изменять значение самого указателя ptrcInt, но сможете изменять значение того, на что ptrcInt указывает.
***Массивы указателей на строки***
Массив указателей — это то же, что и массив переменных типа int или float. Обычно он используется в качестве массива указателей на строки.
char* arrptrs[DAYS] = { "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье" };
Сами строки — это массивы элементов типа char, поэтому массив указателей на строки является массивом указателей на char. Адресом строки является адрес ее первого элемента. Именно эти адреса хранит массив указателей на строки.
***Управление памятью: операции new и delete***
Мы рассмотрели много примеров, в которых массивы использовались без учета размера памяти. В строке int arr1[100]; Компилятор требует, чтобы значение размерности массива было константой. Но во многих ситуациях нам неизвестно требуемое количество памяти до запуска программы.
С++ предлагает другой подход к выделению памяти: операцию ***new***: Это универсальная операция, получающая память у операционной системы и возвращающая указатель на начало выделенного блока.
char* str = "Дурная голова ногам покоя не дает.";
int len = strlen(str);	// вычислим длину нашей строки
char* ptr;		// определим переменную
ptr = new char[len +1];	// выделим память
Предыдущее выражени присваивает переменной ptr значение адреса блока памяти, достаточного для хранения строки str, длину которой можно получить, используя библиотечную функцию strlen() плюс дополнительный байт для символа конца строки.
К сожалению, операции renew (аналог realloc в С) в языке С++ не существует. Вам придется пойти на хитрость, выделить с помощью операции new большее или меньшее количество памяти, а затем скопировать ваши данные в новый блок памяти.
Операция ***delete***
Операция delete предназначена для освобождения выделенных участков памяти, возвращая их операционной системе.
delete[] ptr;
На самом деле в последнем примере нам не нужна эта операция, так как память автоматически освобождается после завершения работы программы. Однако предположим, что мы используем операцию new в функции. Если функция использует локальную переменную как указатель на память, выделенную с использованием new, то указатель будет уничтожен по окончании работы функции, но память останется выделенной и при этом недоступной из программы. Поэтому освобождение памяти после того, как она была использована и больше не требуется, является хорошим тоном, а зачастую и просто необходимо.
ptr = new SomeClass; 	// создаем один объект
delete ptr;		// скобок не требуется
Однако при освобождении памяти, занимаемой массивом, скобки обязательны.
Объекты (как и другие переменные) обычно уничтожаются, когда функция, в которой они определены, заканчивает свою работу. Деструктор гарантирует, что память, выделенная для объекта класса String, будет возвращена системе при уничтожении объекта, а не останется неопределенной.
***Указатели на объекты***
Указатели могут указывать на объекты так же, как и на простые типы данных и массивы.
Distance dist;
где определен объект dist класса Distance. Однако в некоторых случаях на момент написания программы нам неизвестно количество объектов, которое необходимо создать. Тогда мы можем использовать операцию ***new*** для создания объектов во время работы программы.
Distance* distptr;	// определяем переменную-указатель на Distance
distptr = new Distance; // создаем объект Distance
distptr->getdist();	// получаем для него информацию
Операция точки требует, чтобы идентификатор слева был переменной. Так как distptr — указатель на переменную, то в этом случае применяется другой синтаксис. Это другой случай использования операции ***разыменования*** (операции получения содержимого переменной, на которую указывает указатель):
(*distptr).getdist(); 	// так можно: разыменование указателя это переменная
Однако это немного неуклюже из-за скобок (скобки необходимы, так как операция точки (.) имеет больший приоритет, чем операция разыменования (*)). Эквивалентный, но более краткий способ записи предоставляется операцией доступа к членам класса, он состоит из дефиса и знака больше чем:
distptr->getdist(); 	// лучший вариант
***Связный список***
Для хранения данных мы знаем массивы и массивы указателей на данные. Недостатком обеих этих структур является необходимость объявлять фиксированное значение размера массива до запуска программы. Связный список представляет собой более гибкую систему для хранения данных, в которой вовсе не используются массивы. Вместо них мы получаем для каждого элемента память, используя операцию ***new***, а затем соединяем (или связываем) элементы данных между собой, используя указатели. Элементы списка могут быть разбросаны по всему пространству памяти.
struct link {       // один элемент списка
    int data;       // некоторые данные
    link* next;     // указатель на следующую структуру
};
class linklist {    // список
    link* first;
public:
    linklist() { first = NULL; }    // первого элемента пока нет
    void additem(int d);    // добавление элемента
    void display();         // показ данных
};
Функция additem() позволяет нам добавить новый элемент в связный список. Новый элемент вставляется в начало списка.
Связные списки — это наиболее часто встречающаяся после массивов структура для хранения данных. Отличие от массивов - устранена возможная потеря памяти. Недостаток списков в том, что для поиска определенного элемента списка необходимо пройти сквозь весь список от его начала до нужного элемента. И это может занять много времени. А к элементам массива мы можем получить мгновенный доступ, используя индекс элемента, известный заранее.
***Классы, содержащие сами себя***
class sampleclass {
	sampleclass* ptr; 	// так можно
};
Однако хотя класс может содержать в себе указатель на такой же объект, сам этот объект он содержать в себе не может:
class sampleclass {
	sampleclass obj; 	// так нельзя
};
Это справедливо как для классов, так и для структур.
***Указатели на указатели***
void order(person** pp1, person** pp2) {
    if((*pp1)->getName() > (*pp2)->getName()) // если первая строка больше второй,
    {
        person* tempptr = *pp1; // меняем их местами
        *pp1 = *pp2;
        *pp2 = tempptr;
    }
}
void bsort(person** pp, int n) {
    int j, k;   // переменные для циклов
    for(j = 0; j < n - 1; j++)      // внешний цикл
        for(k = j + 1; k < n; k++)  // внутренний цикл
            order(pp + j, pp + k);  // сортируем два элемента
}
main {
	person* persPtr[100]; // массив указателей на person
	do {
        	newPersPtr[countElement] = new newPerson;   // создаем новый объект
        	newPersPtr[countElement]->setName();        // вводим имя
    	} while(choiceNew == 'y');
    	bsort(newPersPtr, countElement);  
}
В действительности, когда мы сортируем объекты типа person, мы не трогаем сами объекты, а работаем с указателями на них. Таким образом мы исключаем необходимость перемещения объектов в памяти, которое отнимает много времени, если объекты очень большие.
person** используются для передачи адреса массива persPtr или, в случае функции order(), адресов элементов массива. Если это массив типа person, то адрес массива будет типа person*. Однако массив ***указателей*** на person имеет адреса своих элементов типа person**. ***Адрес указателя*** — это указатель на указатель.
(*pp1)->getName();
Аргумент pp1 является указателем на указатель, а мы хотим получить содержимое переменной, находящейся по адресу, на который указывает указатель. Для разыменования одного указателя используется операция ->, а для разыменования второго указателя используется операция звездочка, предшествующая указателю pp1. Так как существуют указатели на указатели, то могут быть и указатели на указатели, которые указывают на указатели и т. д.
Указатели могут быть источником таинственных и катастрофических ошибок программы. Наиболее часто встречающейся ошибкой является указатель, которому не присвоили значение перед использованием. В этом случае указатель может указать на любой участок памяти. Если затем в память будет помещено некоторое значение с использованием этого указателя, то оно может записаться вне программы.
Отдельной версией этой проблемы является случай, когда указатель указывает на адрес ***NULL***. Например, это может случиться, если указатель определен как ***глобальная переменная***, так как глобальные переменные автоматически инициализируются 0.
int* intptr;
void main() {
	*intptr = 37;	// глобальная переменная инициализируется нулем
			// нельзя поместить значение 37 по адресу
			// intptr, так как значение intptr равно
			// 0, а это является некорректным значением
			// для указателя
}
Однако встроенная в компилятор проверка ошибок при запуске остановится при попытке доступа к адресу NULL, выведет сообщение об ошибке (это может быть нарушение доступа, присвоение значения нулевому адресу или ошибка из-за отсутствия страницы) и остановит выполнение программы.

# **Глава 11**
# **Виртуальные функции**
В частности, виртуальные функции необходимы при использовании полиморфизма — одного из краеугольных камней ООП.
***Виртуальный*** означает видимый, но не существующий в реальности. Когда используются виртуальные функции, программа, которая, казалось бы, вызывает функцию одного класса, может в этот момент вызывать функцию совсем другого класса.
Представим, что имеется набор объектов разных классов (круг, квадрат, треугольник...), но нам хочется, чтобы они все были в одном массиве и вызывались с помощью одного и того же выражения.
Создадим массив указателей на все неповторяющиеся элементы картинки (круг, квадрат, треугольник...):
shape* ptarr[100]; // массив из 100 указателей на фигуры
Если в этом массиве содержатся указатели на все необходимые геометрические фигуры, то вся картинка может быть нарисована в обычном цикле:
for(int j = 0; j < N; j++)
	ptarr[j]->draw();
Это просто потрясающая возможность! ***Абсолютно разные функции выполняются с помощью одного и того же вызова!*** Если указатель в массиве ptarr указывает на шарик, вызовется функция, рисующая шарик, если он указывает на треугольник, то рисуется треугольник. Вот это и есть ***полиморфизм***, то есть различные формы. Функции выглядят одинаково — это выражение draw(), но реально вызываются разные функции, в зависимости от значения ptarr[j]. ***Полиморфизм*** — одна из ключевых особенностей объектно-ориентированного программирования (ООП) наряду с классами и наследованием.
Чтобы выполнилось условие полиморфизма надо чтобы, все эти классы (треугольнички, шарики и т. д.) являлись ***наследниками*** одного и того же базового класса, например shape. Во-вторых, функция draw() должна быть объявлена виртуальной (***virtual***) в базовом классе.
class Base { 				// Базовый класс
public:
    void show() { cout << "Base\n"; }
};
class Derv1 : public Base {     	// Производный класс 1
public:
    void show() { cout << "Derv1\n"; }
};
class Derv2 : public Base {     	// Производный класс 2
public:
    void show() { cout << "Derv2\n"; }
};
Derv1 dv1;      // Объект производного класса 1
Derv2 dv2;      // Объект производного класса 2
Base* ptr;      // Указатель на базовый класс
ptr = &dv1;     // Адрес dv1 занести в указатель
ptr->show();    // Выполнить show()
Derv1 и Derv2 наследники класса Base.
В данном случае присваиваем адрес объекта одного типа (Derv1) указателю на другой тип (Base). Компилятор не вынесет предупреждений, так как проверка типов отдыхает в этой ситуации. ***Указатели на объекты порожденных классов (Derv1) совместимы по типу с указателями на объекты базового класса (Base).***
Так какая же из функций show() реально вызывается? Результат выполнения программы дает простой ответ:
Base
Base
Как видите, всегда выполняется метод базового класса. Компилятор не смотрит на содержимое указателя ptr, а выбирает тот метод, который удовлетворяет ***типу указателя***.
Теперь поставим ключевое слово ***virtual*** перед объявлением функции show() в базовом классе.
virtual void show() { cout << "Base\n"; }   // Виртуальная функция
Теперь, выполняются методы производных классов, а не базового. Значит, один и тот же вызов ptr->show() ставит на выполнение разные функции в зависимости от содержимого ptr. Компилятор выбирает функцию, удовлетворяющую тому, что ***занесено в указатель***, а не типу указателя.
