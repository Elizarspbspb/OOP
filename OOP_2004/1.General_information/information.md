# **Глава 1**
# **Общие сведения**
## **1. Для чего нужно объектно-ориентированное программирование?**

С, Pascal, FORTRAN и др. сходные с ними языки программирования относятся к категории ***процедурных языков***. Программы, написанные на процедурных языках, представляют собой последовательности инструкций.

Функция (подпрограмма, процедура) - средство, облегчающее восприятие при
чтении текста программы. Программа, построенная на основе процедурного метода, раз-
делена на функции, каждая из которых выполняет некоторую законченную последовательность действий и имеет явно выраженные связи. Модуль - объединение нескольких функций программы(зачастую модуль представляет собой отдельный файл).

#### **Недостаток процедурно-ориентированных языков!**

***1. Неограниченный доступ функций к глобальным данным.*** 

Число возможных связей между глобальными переменными и функциями может быть очень велико

***2. Разделение данных и функций, являющееся основой структурного подхода, плохо отображает картину реального мира.***

Усложняется структура программы. В программу становится трудно вносить изменения. Изменение
структуры глобальных данных может потребовать переписывания всех функций

## **2. Характеристики объектно-ориентированных языков**

***Объект*** в объектно-ориентированном программировании — это модель или абстракция реальной сущности в программной системе. Двумя основными компонентами объекта являются данные и функции, которые выполняют действия над данными. Объекты отображают объекты реального мира точнее, чем функции.

***Класс*** является своего рода формой, определяющей, какие данные и функции будут включены в объект класса. При объявлении класса не создаются никакие объекты этого класса. Когда мы говорим об объектах, мы говорим, что они являются экземплярами классов.

***Наследование*** в ООП как и у функция в про-
цедурном программировании, — призвана сократить размер кода и упростить связи между
элементами программы. Класс также может породить множество подклассов. В C++ класс, который порождает все остальные классы, называется базовым классом, остальные классы наследуют его свойства, одновременно
обладая собственными свойствами. Такие классы называются производными.

***Возможность повторного использования кода.*** Разработанный класс может быть использован в других программах. Аналогичным свойством в процедурном программировании обладают библиотеки функций, которые можно включать в различные программные проекты.

Одним из достоинств объектов является то, что они дают пользователю возможность создавать свои ***собственные типы данных.***

***Полиморфизм*** - использование операций и функций различным образом в зависимости от
того, с какими типами величин они работают. Когда существующая операция, например = или +, наделяется возможностью совершать действия над операндами нового типа, говорят, что такая операция является перегруженной. 

Возможность выполнения оператором или функцией различных действий в зависимости от типа операндов называется ***полиморфизм***.

***Перегрузка*** представляет собой частный случай полиморфизма и является важным инструментом ООП. Операция, выполняющая заданные действия над пользовательским типом
данных, называется ***перегруженной.***

Защита данных от несанкционированного доступа другими функциями называется ***сокрытием данных.***

***Инкапсуляция*** - объединение данных и функций. Это принцип, согласно которому внутреннее устройство сущностей нужно объединять в специальной «оболочке» и скрывать от вмешательств извне. Доступ возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.

Если язык обеспечивает возможность создания пользовательских типов данных, то говорят, что язык называется ***расширяемым***.

## **3. С++ и С**

C++ является расширением языка С: любая конструкция на языке C является корректной в C++; в то же время обратное неверно. Наиболее значительные нововведения, присутствующие в C++, касаются ***классов, объектов и ООП*** (первоначальное название языка C++ — «С с классами»). Тем не менее имеются и другие усовершенствования, связанные со способами организации ввода/вывода и комментариями.
***С++ объектно-ориентированный язык программирования.***

В C++ функцию, входящую в состав класса, называют - функция-член класса. Однако ***Метод*** в объектно-ориентированном программировании — это функция или процедура, принадлежащая какому-то классу или объекту.


## **4. Универсальный язык моделирования (UML)**

***UML*** можно условно называть графическим языком, предназначенным для моделирования компьютерных программ. Создание наглядной визуальной интерпретации.

Наиболее важным средством UML является набор различных видов диаграмм. Диаграммы классов иллюстрируют отношения между различными классами, диаграммы объектов — между отдельными объектами, диаграммы связей
отражают связь объектов во времени и т. д.

UML является лишь средством для иллюстрирования
разрабатываемого проекта.

# **Глава 4**
# **Структуры**
***Структура*** является объединением простых переменных. Эти переменные могут иметь различные типы: int, float и т. д. (Переменные, входящие в состав структуры, называются ***полями*** структуры.
Синтаксис структуры идентичен синтаксису класса. Отличие структуры от класса заключается в следующем: структуры, как правило, используют в качестве объединения данных, а классы — в качестве объединения данных и функций. В структуре все поля по-умолчанию открытые, а в классе закрытые. Одним из достоинств классов является возможность определять сложение и другие операции над пользовательскими типами данных.
Само определение структуры не создает никаких переменных - не происходит ни выделения физической памяти, ни объявления переменной. А при создании объекта структуры выделяется память. Под структурную переменную отводится столько памяти, сколько достаточно для хранения всех ее полей. Доступ к полям структуры осуществляются с помощью операции ***доступ к полю структуры***. Проводить мат. действия с объектами невозможно без переопределения операции.
***Перечисления*** - пользовательский тип данных. Объявление типа начинается со слова ***enum*** и содержит перечисление всех возможных значений переменных создаваемого типа. Инициализируются целыми значениями от 0 и т.д., перечисление констант. 

# **Глава 5**
# **Функции**
Наиболее важной причиной использования функций служит необходимость концептуализировать структуру программы.
Любая последовательность операторов, встречающаяся в программе более одного раза, будучи вынесенной в отдельную функцию, сокращает размер программы.
Что необходимо добавить в программу для использования дополнительных функций? Обязательными являются три компонента: ***объявление функции***, ее ***определение*** и ***вызовы***.
***Объявления функций*** также называют ***прототипами функций***, поскольку они являются неким общим представлением или описанием функций. Прототип говорит компилятору о том, что «функция, имеющая данные атрибуты, будет написана позже, и 
можно вызывать эту функцию до того, как будет обнаружен ее код». Информацию о функции, содержащуюся в ее объявлении (тип возвращаемого значения, а также число и типы аргументов функции) также иногда называют ***сигнатурой*** функции.
Переменные, используемые внутри функции для хранения значений аргументов, называются параметрами.
Способ передачи аргументов, при котором функция создает копии передаваемых значений, называется ***передачей аргументов по значению***.
В случае, если функция возвращает значение, тип этого значения должен быть определен. 
Тип возвращаемого значения указывается перед именем функции при объявлении и определении функции.
Количество аргументов у функции может быть сколь угодно большим, но возвращаемое значение всегда только одно. А если надо вернуть больше, то возможна передача аргументов по ссылке или вернуть структурную переменную с полями.
Если же вы не укажете возвращаемый тип данных при объявлении функции, то по умолчанию возвращаемым типом будет int.
Ссылка является псевдонимом, или альтернативным именем переменной. Вместо того чтобы передавать функции значение переменной, ей передается ссылка на эту переменную (адрес переменной-аргумента в памяти).
Если какие-либо аргументы передаются в функцию по ссылке, то в прототипе функции необходимо с помощью знака & указывать соответствующий параметр-ссылку.
В языке C не существует понятия ***ссылка***. Схожие с ссылками возможности в С обеспечивают указатели, хотя зачастую их применение менее удобно. 
Создание ссылочного механизма в C++ было обусловлено стремлением обеспечить гибкость языка в ситуациях, связанных с использованием как объектов, так и простых переменных.
Третьим способом передачи аргументов в функцию является использование указателей. Мы рассмотрим этот способ в главе 10 «Указатели».
***Перегруженная функция*** выполняет различные действия, зависящие от типов данных, передаваемых ей в качестве аргументов.
***1. Переменное число аргументов функции*** 
void repchar();			// прототипы
void repchar(char);
void repchar(char, int);
***2. Различные типы аргументов***
void engldisp(Distance);	// прототипы
void engldisp(float);
***Рекурсия***
Существование функций делает возможным использование такого средства программирования, как рекурсия. Рекурсия позволяет функции вызывать саму себя на выполнение.
Каждая рекурсивная функция должна включать в себя условие окончания рекурсии. В противном случае рекурсия будет происходить бесконечно, что приведет к аварийному завершению программы.
***Встраиваемые функции***
Использование функций является экономичным (избавляет от дублирования кода). Когда компилятор встречает вызов функции, он генерирует команду перехода в эту функцию. После выполнения функции осуществляется переход на оператор, следующий за вызовом функции.
Использование функций, наряду с сокращением размера памяти, увеличивает время выполнения программы. Для выполнения функции должны быть сгенерированы команды переходов (инструкция ассемблера CALL), команды, сохраняющие значения регистров процессора, команды, помещающие в стек и извлекающие из стека аргументы функции, команды, восстанавливающие значения регистров после выполнения функции, и наконец, команда перехода из функции обратно в программу.
Для того чтобы сократить время выполнения небольших функций, можно дать указание компилятору, чтобы при каждом вызове такой функции вместо команды перехода производилась подстановка операторов, выполняемых функцией, в код программы.
Длинные повторяющиеся последовательности действий лучше объединять в обычные функции, поскольку экономия памяти в этом случае оправдывает накладные расходы на время выполнения программы. Но если вынести в функцию небольшой фрагмент кода, то выигрыш от экономии памяти будет мал, а дополнительные временные затраты останутся почти на том же уровне, что и для функции большого объема. Решением данной проблемы служит использование встраиваемых функций.
Встраиваемые функции ***inline*** пишутся так же, как и обычные, но при компиляции их исполняемый код вставляется, или встраивается, в исполняемый код программы. Встраиваемыми следует делать только очень короткие функции (один-два оператора).
Ключевое слово ***inline*** является лишь рекомендацией компилятору, которая может быть проигнорирована. В этом случае функция будет скомпилирована как обычная. Такое может произойти, например, в том слу-
чае, если компилятор посчитает функцию слишком длинной.
В языке C, встраиваемые функции являются аналогом широко используемого макроса ***#define***.
