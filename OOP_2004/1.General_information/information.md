# **Глава 1**
# **Общие сведения**
## **1. Для чего нужно объектно-ориентированное программирование?**

С, Pascal, FORTRAN и др. сходные с ними языки программирования относятся к категории ***процедурных языков***. Программы, написанные на процедурных языках, представляют собой последовательности инструкций.

Функция (подпрограмма, процедура) - средство, облегчающее восприятие при
чтении текста программы. Программа, построенная на основе процедурного метода, раз-
делена на функции, каждая из которых выполняет некоторую законченную последовательность действий и имеет явно выраженные связи. Модуль - объединение нескольких функций программы(зачастую модуль представляет собой отдельный файл).

#### **Недостаток процедурно-ориентированных языков!**

***1. Неограниченный доступ функций к глобальным данным.*** 

Число возможных связей между глобальными переменными и функциями может быть очень велико

***2. Разделение данных и функций, являющееся основой структурного подхода, плохо отображает картину реального мира.***

Усложняется структура программы. В программу становится трудно вносить изменения. Изменение
структуры глобальных данных может потребовать переписывания всех функций

## **2. Характеристики объектно-ориентированных языков**

***Объект*** в объектно-ориентированном программировании — это модель или абстракция реальной сущности в программной системе. Двумя основными компонентами объекта являются данные и функции, которые выполняют действия над данными. Объекты отображают объекты реального мира точнее, чем функции.

***Класс*** является своего рода формой, определяющей, какие данные и функции будут включены в объект класса. При объявлении класса не создаются никакие объекты этого класса. Когда мы говорим об объектах, мы говорим, что они являются экземплярами классов.

***Наследование*** в ООП как и у функция в про-
цедурном программировании, — призвана сократить размер кода и упростить связи между
элементами программы. Класс также может породить множество подклассов. В C++ класс, который порождает все остальные классы, называется базовым классом, остальные классы наследуют его свойства, одновременно
обладая собственными свойствами. Такие классы называются производными.

***Возможность повторного использования кода.*** Разработанный класс может быть использован в других программах. Аналогичным свойством в процедурном программировании обладают библиотеки функций, которые можно включать в различные программные проекты.

Одним из достоинств объектов является то, что они дают пользователю возможность создавать свои ***собственные типы данных.***

***Полиморфизм*** - использование операций и функций различным образом в зависимости от
того, с какими типами величин они работают. Когда существующая операция, например = или +, наделяется возможностью совершать действия над операндами нового типа, говорят, что такая операция является перегруженной. 

Возможность выполнения оператором или функцией различных действий в зависимости от типа операндов называется ***полиморфизм***.

***Перегрузка*** представляет собой частный случай полиморфизма и является важным инструментом ООП. Операция, выполняющая заданные действия над пользовательским типом
данных, называется ***перегруженной.***

Защита данных от несанкционированного доступа другими функциями называется ***сокрытием данных.***

***Инкапсуляция*** - объединение данных и функций. Это принцип, согласно которому внутреннее устройство сущностей нужно объединять в специальной «оболочке» и скрывать от вмешательств извне. Доступ возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.

Если язык обеспечивает возможность создания пользовательских типов данных, то говорят, что язык называется ***расширяемым***.

## **3. С++ и С**

C++ является расширением языка С: любая конструкция на языке C является корректной в C++; в то же время обратное неверно. Наиболее значительные нововведения, присутствующие в C++, касаются ***классов, объектов и ООП*** (первоначальное название языка C++ — «С с классами»). Тем не менее имеются и другие усовершенствования, связанные со способами организации ввода/вывода и комментариями.
***С++ объектно-ориентированный язык программирования.***

В C++ функцию, входящую в состав класса, называют - функция-член класса. Однако ***Метод*** в объектно-ориентированном программировании — это функция или процедура, принадлежащая какому-то классу или объекту.


## **4. Универсальный язык моделирования (UML)**

***UML*** можно условно называть графическим языком, предназначенным для моделирования компьютерных программ. Создание наглядной визуальной интерпретации.

Наиболее важным средством UML является набор различных видов диаграмм. Диаграммы классов иллюстрируют отношения между различными классами, диаграммы объектов — между отдельными объектами, диаграммы связей
отражают связь объектов во времени и т. д.

UML является лишь средством для иллюстрирования
разрабатываемого проекта.

# **Глава 4**
# **Структуры**
***Структура*** является объединением простых переменных. Эти переменные могут иметь различные типы: int, float и т. д. (Переменные, входящие в состав структуры, называются ***полями*** структуры.
Синтаксис структуры идентичен синтаксису класса. Отличие структуры от класса заключается в следующем: структуры, как правило, используют в качестве объединения данных, а классы — в качестве объединения данных и функций. В структуре все поля по-умолчанию открытые, а в классе закрытые. Одним из достоинств классов является возможность определять сложение и другие операции над пользовательскими типами данных.
Само определение структуры не создает никаких переменных - не происходит ни выделения физической памяти, ни объявления переменной. А при создании объекта структуры выделяется память. Под структурную переменную отводится столько памяти, сколько достаточно для хранения всех ее полей. Доступ к полям структуры осуществляются с помощью операции ***доступ к полю структуры***. Проводить мат. действия с объектами невозможно без переопределения операции.
***Перечисления*** - пользовательский тип данных. Объявление типа начинается со слова ***enum*** и содержит перечисление всех возможных значений переменных создаваемого типа. Инициализируются целыми значениями от 0 и т.д., перечисление констант. 

# **Глава 5**
# **Функции**
Наиболее важной причиной использования функций служит необходимость концептуализировать структуру программы.
Любая последовательность операторов, встречающаяся в программе более одного раза, будучи вынесенной в отдельную функцию, сокращает размер программы.
Что необходимо добавить в программу для использования дополнительных функций? Обязательными являются три компонента: ***объявление функции***, ее ***определение*** и ***вызовы***.
***Объявления функций*** также называют ***прототипами функций***, поскольку они являются неким общим представлением или описанием функций. Прототип говорит компилятору о том, что «функция, имеющая данные атрибуты, будет написана позже, и 
можно вызывать эту функцию до того, как будет обнаружен ее код». Информацию о функции, содержащуюся в ее объявлении (тип возвращаемого значения, а также число и типы аргументов функции) также иногда называют ***сигнатурой*** функции.
Переменные, используемые внутри функции для хранения значений аргументов, называются параметрами.
Способ передачи аргументов, при котором функция создает копии передаваемых значений, называется ***передачей аргументов по значению***.
В случае, если функция возвращает значение, тип этого значения должен быть определен. 
Тип возвращаемого значения указывается перед именем функции при объявлении и определении функции.
Количество аргументов у функции может быть сколь угодно большим, но возвращаемое значение всегда только одно. А если надо вернуть больше, то возможна передача аргументов по ссылке или вернуть структурную переменную с полями.
Если же вы не укажете возвращаемый тип данных при объявлении функции, то по умолчанию возвращаемым типом будет int.
Ссылка является псевдонимом, или альтернативным именем переменной. Вместо того чтобы передавать функции значение переменной, ей передается ссылка на эту переменную (адрес переменной-аргумента в памяти).
Если какие-либо аргументы передаются в функцию по ссылке, то в прототипе функции необходимо с помощью знака & указывать соответствующий параметр-ссылку.
В языке C не существует понятия ***ссылка***. Схожие с ссылками возможности в С обеспечивают указатели, хотя зачастую их применение менее удобно. 
Создание ссылочного механизма в C++ было обусловлено стремлением обеспечить гибкость языка в ситуациях, связанных с использованием как объектов, так и простых переменных.
Третьим способом передачи аргументов в функцию является использование указателей. Мы рассмотрим этот способ в главе 10 «Указатели».
***Перегруженная функция*** выполняет различные действия, зависящие от типов данных, передаваемых ей в качестве аргументов.
***1. Переменное число аргументов функции*** 
void repchar();			// прототипы
void repchar(char);
void repchar(char, int);
***2. Различные типы аргументов***
void engldisp(Distance);	// прототипы
void engldisp(float);
***Рекурсия***
Существование функций делает возможным использование такого средства программирования, как рекурсия. Рекурсия позволяет функции вызывать саму себя на выполнение.
Каждая рекурсивная функция должна включать в себя условие окончания рекурсии. В противном случае рекурсия будет происходить бесконечно, что приведет к аварийному завершению программы.
***Встраиваемые функции***
Использование функций является экономичным (избавляет от дублирования кода). Когда компилятор встречает вызов функции, он генерирует команду перехода в эту функцию. После выполнения функции осуществляется переход на оператор, следующий за вызовом функции.
Использование функций, наряду с сокращением размера памяти, увеличивает время выполнения программы. Для выполнения функции должны быть сгенерированы команды переходов (инструкция ассемблера CALL), команды, сохраняющие значения регистров процессора, команды, помещающие в стек и извлекающие из стека аргументы функции, команды, восстанавливающие значения регистров после выполнения функции, и наконец, команда перехода из функции обратно в программу.
Для того чтобы сократить время выполнения небольших функций, можно дать указание компилятору, чтобы при каждом вызове такой функции вместо команды перехода производилась подстановка операторов, выполняемых функцией, в код программы.
Длинные повторяющиеся последовательности действий лучше объединять в обычные функции, поскольку экономия памяти в этом случае оправдывает накладные расходы на время выполнения программы. Но если вынести в функцию небольшой фрагмент кода, то выигрыш от экономии памяти будет мал, а дополнительные временные затраты останутся почти на том же уровне, что и для функции большого объема. Решением данной проблемы служит использование встраиваемых функций.
Встраиваемые функции ***inline*** пишутся так же, как и обычные, но при компиляции их исполняемый код вставляется, или встраивается, в исполняемый код программы. Встраиваемыми следует делать только очень короткие функции (один-два оператора). Встроенные функции исполняются быстрее, но могут занимать в памяти больше места, чем обычные функции, если только размер встроенных функций не является очень маленьким.
Ключевое слово ***inline*** является лишь рекомендацией компилятору, которая может быть проигнорирована. В этом случае функция будет скомпилирована как обычная. Такое может произойти, например, в том случае, если компилятор посчитает функцию слишком длинной.
В языке C, встраиваемые функции являются аналогом широко используемого макроса ***#define***.
Можно организовать функцию, имеющую аргументы, таким образом, чтоб вызывать ее, вообще не указывая при этом никаких аргументов. Однако для этого при объявлении функции необходимо задать значения ***аргументов по умолчанию***.
Если при вызове функции число переданных аргументов на единицу меньше, чем описано в прототипе, то компилятор считает, что отсутствует последний аргумент и установит его значение по умолчанию.
Обратите внимание, что опускать при вызове можно только аргументы, стоящие в конце списка при объявлении функции. Задание значений аргументов по умолчанию полезно в тех случаях, когда аргументы функции часто принимают какое-то одно значение. 
***Область видимости*** определяет, из каких частей программы возможен доступ к переменной, а 
***класс памяти*** — время, в течение которого переменная существует в памяти компьютера.
Переменные, имеющие ***локальную область видимости***, доступны внутри того блока, в котором они определены.
Переменные, имеющие ***область видимости файла***, доступны из любого места файла, в котором они определены.
***Блоком*** обычно считается код, заключенный в фигурные скобки.
Существует два класса памяти: ***automatic*** (автоматический) и ***static*** (статический).
У переменных, имеющих класс памяти ***automatic***, время жизни равно времени жизни функции, внутри которой они определены.
У переменных, имеющих класс памяти ***static***, время жизни равно времени жизни всей программы.
Статические локальные переменные используются в тех случаях, когда необходимо сохранить значение переменной в памяти после того, как выполнение функции будет завершено, или, другими словами, между вызовами функций.
Подобно тому как мы передавали в функцию аргументы с помощью ссылок, мы можем возвращать значение функции по
ссылке (Виртуальные функции) для избежания копирования больших объектов. Функция, возвращающая ссылку, интерпрети-
руется как переменная. С помощью ссылки вы не можете возвратить из функции константу.
В случае, если аргумент занимает много места в памяти, его передача по ссылке является гораздо более эффективной, поскольку в последнем случае в функцию передается не значение переменной, а только ее адрес.
Предположим, что вы используете ссылочный механизм только из соображений эффективности и при этом не хотите, чтобы функция имела свободный доступ к аргументу и изменяла его значение. Для того чтобы получить подобную гарантию, вы можете указать модификатор const перед соответствующим аргументом в прототипе функции.
Если вы желаете передать в функцию константную переменную с помощью ссылки, у вас не остается другого выбора, как использовать модификатор const в прототипе функции.
# **Глава 6**
# **Объекты и классы**
Объект является экземпляром класса, так же, как автомобиль является экземпляром колесного средства передвижения. 
Ключевой особенностью объектно-ориентированного программирования является возможность сокрытия данных. Этот термин понимается в том смысле, что данные заключены внутри класса и защищены от несанкционированного доступа функций, расположенных вне класса. Если необходимо защитить какиелибо данные, то их помещают внутрь класса с ключевым словом ***private***. Такие данные доступны только внутри класса. Данные, описанные с ключевым словом ***public***, напротив, доступны за пределами класса.
Сокрытие данных в нашем толковании означает ограждение данных от тех частей программы, которые не имеют необходимости использовать эти данные. В более узком смысле это означает сокрытие данных одного класса от другого класса. Сокрытие данных позволяет уберечь опытных программистов от своих собственных ошибок. Программисты могут сами создать средства доступа к закрытым данным, что значительно снижает вероятность случайного или некорректного доступа к ним.
***Данные***, содержащиеся внутри класса, называют данными-членами или ***полями класса***. Число полей класса, как и у структуры, теоретически может быть любым.
***Методы класса*** — это функции, входящие в состав класса.
Методы класса, определенные внутри класса, по умолчанию являются встраиваемыми. Функция, определенная вне класса, по умолчанию уже не является встраиваемой. Доступ к методам класса возможен только через конкретный объект этого класса.
Обратите внимание на то, что при определении класса не создаются никакие его объекты. Определение класса лишь задает вид будущего объекта, подобно тому, как определение структуры не выделяет память под структурные переменные, а лишь описывает их организацию. Все операции программа производит с объектами. Определение объекта похоже на определение переменной: оно означает выделение памяти, необходимой для хранения объекта.
Для того чтобы получить доступ к методу класса, необходимо использовать операцию точки (.) (операцию точки называют операцией доступа к члену класса).
Удобнее инициализировать поля объекта автоматически в момент его создания, а не явно вызывать в программе соответствующий метод. Такой способ инициализации реализуется с помощью особого метода класса, называемого конструктором. ***Конструктор*** — это метод класса, выполняющийся автоматически в момент создания объекта. При создании каждого объекта вызывается конструктор класса, присваивающий полям нулевое значение по-умолчанию. Имя конструктора в точности совпадает с именем класса. Таким образом, компилятор отличает конструкторы от других методов класса. У конструкторов не существует возвращаемого значения.
Counter()
{ count = 0; }
Такая форма записи не рекомендуется, несмотря на то, что она не содержит ошибок. 
Инициализация в нашем примере происходит следующим образом:
Counter() : count(0) { }
Список инициализации:
SomeClass() : m1(7), m2(33), m3(4) { }
Инициализация полей с помощью списка инициализации происходит до начала исполнения тела конструктора, что бывает важно.
Конструктор без параметров называется ***конструктором по умолчанию***. Если бы конструктор по умолчанию не создавался автоматически, то мы не смогли бы определять переменные классов, в которых отсутствует конструктор.
Если же для нас важно, какими значениями будут инициализироваться поля объекта класса, то нам следует явно определить конструктор.
Два явно определенных конструктора с одним и тем же именем является ***перегруженным***.
В примере ENGLCON метод add_dist() определен вне класса Distance(). Внутри определения класса содержится лишь прототип функции add_dist();
void Distance::add_dist(Distance dd1, Distance dd2)
:: - символ является знаком ***операции глобального разрешения***. Такая форма записи устанавливает взаимосвязь функции и класса, к которой относится эта функция.
Рассмотрим третий способ инициализации объекта, использующий значения полей уже существующего объекта. ***Копирующим конструктором по умолчанию***. Копирующий конструктор имеет единственный аргумент, являющийся объектом того же класса, что и конструктор.
Distance dist1(11, 6.25); // конструктор с двумя аргументами
Distance dist2(dist1);	// два конструктора с одним аргументом
Distance dist3 = dist1;
Мы инициализировали объект dist1 значением 11'-6.25" при помощи конструктора с двумя аргументами. Затем мы определяем еще два объекта класса Distance с именами dist2 и dist3, оба из которых инициализируются значением объекта dist1. Поскольку аргументом являлся объект того же класса, был вызван копирующий конструктор по умолчанию. Distance dist2(dist1) Действие копирующего конструктора по умолчанию сводится к копированию значений полей объекта dist1 в соответствующие поля объекта dist2. 
Идентичные действия для пары объектов dist1 и dist3 выполняются при помощи оператора Distance dist3 = dist1; Здесь, как и в предыдущем случае, вызывается конструктор копирования по умолчанию.
***Деструкторы*** - функция, автоматически вызываемая при уничтожении объекта. Деструктор имеет имя, совпадающее с именем конструктора и предваряющееся символом ~. Подобно конструкторам, деструкторы не возвращают значения и не имеют аргументов.
***Структуры*** предназначены для объединения данных, а ***классы*** — для объединения данных и функций. На самом деле, в большинстве ситуаций можно использовать структуры так же, как и классы. Формально ***разница между структурами и классами*** заключается лишь в том, что по умолчанию все члены класса являются скрытыми, а все члены структуры — открытыми.
Если поле данных класса описано с ключевым словом ***static***, то значение этого поля будет одинаковым для всех объектов данного класса.
Статические данные класса полезны в тех случаях, когда необходимо, чтобы все объекты включали в себя какое-либо одинаковое значение. Статическое поле по своим характеристикам схоже со статической переменной: оно видимо только внутри класса, но время его жизни совпадает со временем жизни программы. ***Определение статических полей*** класса происходит не так, как для обычных полей. Объявление поля находится внутри определения класса, а определение поля располагается вне класса и зачастую представляет собой определение глобальной переменной. Если бы определение статического поля класса находилось внутри класса, то это нарушило бы принцип, в соответствии с которым определение класса не должно быть связано с выделением памяти. Если вы объявите статическое поле класса, но забудете его определить, компилятор не выдаст предупреждающего сообщения.
В памяти компьютера каждый объект имеет свои собственные участки, хранящие значения полей этого объекта, но методы класса хранятся в памяти в единственном экземпляре.
***Константные методы класса***
Константные методы ***const*** отличаются тем, что не изменяют значений полей своего класса. Те методы, которые лишь считывают данные из поля класса, имеет смысл делать константными, поскольку у них нет необходимости изменять значения полей объектов класса. С помощью константных функций можно создавать и использовать константные объекты, как мы увидим позже.
***Константные аргументы методов***
Если необходимо передать аргумент в функцию ***по ссылке*** и в то же время ***защитить его от изменения функцией***, необходимо сделать этот аргумент константным при объявлении и определении функции.
***Константные объекты***
Если объект класса объявлен с модификатором ***const***, он становится недоступным для изменения. Это означает, что для такого объекта можно вызывать только константные методы.
const Distance football(300, 0);
Когда вы создаете класс, всегда является хорошим стилем объявлять константными функции, не изменяющие полей объектов класса. Это позволяет тому, кто использует данный класс, создавать константные объекты класса. Из этих объектов могут вызываться только константные функции.
Первым достоинством ***объектно-ориентированного программирования*** является то, что оно обеспечивает значительное сходство между объектами реального мира, моделируемыми программой, и объектами классов C++.

