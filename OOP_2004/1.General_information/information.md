# **Глава 1**
# **Общие сведения**
## **1. Для чего нужно объектно-ориентированное программирование?**

С, Pascal, FORTRAN и др. сходные с ними языки программирования относятся к категории ***процедурных языков***. Программы, написанные на процедурных языках, представляют собой последовательности инструкций.

Функция (подпрограмма, процедура) - средство, облегчающее восприятие при
чтении текста программы. Программа, построенная на основе процедурного метода, раз-
делена на функции, каждая из которых выполняет некоторую законченную последовательность действий и имеет явно выраженные связи. Модуль - объединение нескольких функций программы(зачастую модуль представляет собой отдельный файл).

#### **Недостаток процедурно-ориентированных языков!**

***1. Неограниченный доступ функций к глобальным данным.*** 

Число возможных связей между глобальными переменными и функциями может быть очень велико

***2. Разделение данных и функций, являющееся основой структурного подхода, плохо отображает картину реального мира.***

Усложняется структура программы. В программу становится трудно вносить изменения. Изменение
структуры глобальных данных может потребовать переписывания всех функций

## **2. Характеристики объектно-ориентированных языков**

***Объект*** в объектно-ориентированном программировании — это модель или абстракция реальной сущности в программной системе. Двумя основными компонентами объекта являются данные и функции, которые выполняют действия над данными. Объекты отображают объекты реального мира точнее, чем функции.

***Класс*** является своего рода формой, определяющей, какие данные и функции будут включены в объект класса. При объявлении класса не создаются никакие объекты этого класса. Когда мы говорим об объектах, мы говорим, что они являются экземплярами классов.

***Наследование*** в ООП как и у функция в про-
цедурном программировании, — призвана сократить размер кода и упростить связи между
элементами программы. Класс также может породить множество подклассов. В C++ класс, который порождает все остальные классы, называется базовым классом, остальные классы наследуют его свойства, одновременно
обладая собственными свойствами. Такие классы называются производными.

***Возможность повторного использования кода.*** Разработанный класс может быть использован в других программах. Аналогичным свойством в процедурном программировании обладают библиотеки функций, которые можно включать в различные программные проекты.

Одним из достоинств объектов является то, что они дают пользователю возможность создавать свои ***собственные типы данных.***

***Полиморфизм*** - использование операций и функций различным образом в зависимости от
того, с какими типами величин они работают. Когда существующая операция, например = или +, наделяется возможностью совершать действия над операндами нового типа, говорят, что такая операция является перегруженной. 

Возможность выполнения оператором или функцией различных действий в зависимости от типа операндов называется ***полиморфизм***.

***Перегрузка*** представляет собой частный случай полиморфизма и является важным инструментом ООП. Операция, выполняющая заданные действия над пользовательским типом
данных, называется ***перегруженной.***

Защита данных от несанкционированного доступа другими функциями называется ***сокрытием данных.***

***Инкапсуляция*** - объединение данных и функций. Это принцип, согласно которому внутреннее устройство сущностей нужно объединять в специальной «оболочке» и скрывать от вмешательств извне. Доступ возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.

Если язык обеспечивает возможность создания пользовательских типов данных, то говорят, что язык называется ***расширяемым***.

## **3. С++ и С**

C++ является расширением языка С: любая конструкция на языке C является корректной в C++; в то же время обратное неверно. Наиболее значительные нововведения, присутствующие в C++, касаются ***классов, объектов и ООП*** (первоначальное название языка C++ — «С с классами»). Тем не менее имеются и другие усовершенствования, связанные со способами организации ввода/вывода и комментариями.
***С++ объектно-ориентированный язык программирования.***

В C++ функцию, входящую в состав класса, называют - функция-член класса. Однако ***Метод*** в объектно-ориентированном программировании — это функция или процедура, принадлежащая какому-то классу или объекту.


## **4. Универсальный язык моделирования (UML)**

***UML*** можно условно называть графическим языком, предназначенным для моделирования компьютерных программ. Создание наглядной визуальной интерпретации.

Наиболее важным средством UML является набор различных видов диаграмм. Диаграммы классов иллюстрируют отношения между различными классами, диаграммы объектов — между отдельными объектами, диаграммы связей
отражают связь объектов во времени и т. д.

UML является лишь средством для иллюстрирования
разрабатываемого проекта.

# **Глава 4**
# **Структуры**
***Структура*** является объединением простых переменных. Эти переменные могут иметь различные типы: int, float и т. д. (Переменные, входящие в состав структуры, называются ***полями*** структуры.
Синтаксис структуры идентичен синтаксису класса. Отличие структуры от класса заключается в следующем: структуры, как правило, используют в качестве объединения данных, а классы — в качестве объединения данных и функций. В структуре все поля по-умолчанию открытые, а в классе закрытые. Одним из достоинств классов является возможность определять сложение и другие операции над пользовательскими типами данных.
Само определение структуры не создает никаких переменных - не происходит ни выделения физической памяти, ни объявления переменной. А при создании объекта структуры выделяется память. Под структурную переменную отводится столько памяти, сколько достаточно для хранения всех ее полей. Доступ к полям структуры осуществляются с помощью операции ***доступ к полю структуры***. Проводить мат. действия с объектами невозможно без переопределения операции.
***Перечисления*** - пользовательский тип данных. Объявление типа начинается со слова ***enum*** и содержит перечисление всех возможных значений переменных создаваемого типа. Инициализируются целыми значениями от 0 и т.д., перечисление констант. 

# **Глава 5**
# **Функции**
Наиболее важной причиной использования функций служит необходимость концептуализировать структуру программы.
Любая последовательность операторов, встречающаяся в программе более одного раза, будучи вынесенной в отдельную функцию, сокращает размер программы.
Что необходимо добавить в программу для использования дополнительных функций? Обязательными являются три компонента: ***объявление функции***, ее ***определение*** и ***вызовы***.
***Объявления функций*** также называют ***прототипами функций***, поскольку они являются неким общим представлением или описанием функций. Прототип говорит компилятору о том, что «функция, имеющая данные атрибуты, будет написана позже, и 
можно вызывать эту функцию до того, как будет обнаружен ее код». Информацию о функции, содержащуюся в ее объявлении (тип возвращаемого значения, а также число и типы аргументов функции) также иногда называют ***сигнатурой*** функции.
Переменные, используемые внутри функции для хранения значений аргументов, называются параметрами.
Способ передачи аргументов, при котором функция создает копии передаваемых значений, называется ***передачей аргументов по значению***.
В случае, если функция возвращает значение, тип этого значения должен быть определен. 
Тип возвращаемого значения указывается перед именем функции при объявлении и определении функции.
Количество аргументов у функции может быть сколь угодно большим, но возвращаемое значение всегда только одно. А если надо вернуть больше, то возможна передача аргументов по ссылке или вернуть структурную переменную с полями.
Если же вы не укажете возвращаемый тип данных при объявлении функции, то по умолчанию возвращаемым типом будет int.
Ссылка является псевдонимом, или альтернативным именем переменной. Вместо того чтобы передавать функции значение переменной, ей передается ссылка на эту переменную (адрес переменной-аргумента в памяти).
Если какие-либо аргументы передаются в функцию по ссылке, то в прототипе функции необходимо с помощью знака & указывать соответствующий параметр-ссылку.
В языке C не существует понятия ***ссылка***. Схожие с ссылками возможности в С обеспечивают указатели, хотя зачастую их применение менее удобно. 
Создание ссылочного механизма в C++ было обусловлено стремлением обеспечить гибкость языка в ситуациях, связанных с использованием как объектов, так и простых переменных.
Третьим способом передачи аргументов в функцию является использование указателей. Мы рассмотрим этот способ в главе 10 «Указатели».
***Перегруженная функция*** выполняет различные действия, зависящие от типов данных, передаваемых ей в качестве аргументов.
***1. Переменное число аргументов функции*** 
void repchar();			// прототипы
void repchar(char);
void repchar(char, int);
***2. Различные типы аргументов***
void engldisp(Distance);	// прототипы
void engldisp(float);
***Рекурсия***
Существование функций делает возможным использование такого средства программирования, как рекурсия. Рекурсия позволяет функции вызывать саму себя на выполнение.
Каждая рекурсивная функция должна включать в себя условие окончания рекурсии. В противном случае рекурсия будет происходить бесконечно, что приведет к аварийному завершению программы.
***Встраиваемые функции***
Использование функций является экономичным (избавляет от дублирования кода). Когда компилятор встречает вызов функции, он генерирует команду перехода в эту функцию. После выполнения функции осуществляется переход на оператор, следующий за вызовом функции.
Использование функций, наряду с сокращением размера памяти, увеличивает время выполнения программы. Для выполнения функции должны быть сгенерированы команды переходов (инструкция ассемблера CALL), команды, сохраняющие значения регистров процессора, команды, помещающие в стек и извлекающие из стека аргументы функции, команды, восстанавливающие значения регистров после выполнения функции, и наконец, команда перехода из функции обратно в программу.
Для того чтобы сократить время выполнения небольших функций, можно дать указание компилятору, чтобы при каждом вызове такой функции вместо команды перехода производилась подстановка операторов, выполняемых функцией, в код программы.
Длинные повторяющиеся последовательности действий лучше объединять в обычные функции, поскольку экономия памяти в этом случае оправдывает накладные расходы на время выполнения программы. Но если вынести в функцию небольшой фрагмент кода, то выигрыш от экономии памяти будет мал, а дополнительные временные затраты останутся почти на том же уровне, что и для функции большого объема. Решением данной проблемы служит использование встраиваемых функций.
Встраиваемые функции ***inline*** пишутся так же, как и обычные, но при компиляции их исполняемый код вставляется, или встраивается, в исполняемый код программы. Встраиваемыми следует делать только очень короткие функции (один-два оператора). Встроенные функции исполняются быстрее, но могут занимать в памяти больше места, чем обычные функции, если только размер встроенных функций не является очень маленьким.
Ключевое слово ***inline*** является лишь рекомендацией компилятору, которая может быть проигнорирована. В этом случае функция будет скомпилирована как обычная. Такое может произойти, например, в том случае, если компилятор посчитает функцию слишком длинной.
В языке C, встраиваемые функции являются аналогом широко используемого макроса ***#define***.
Можно организовать функцию, имеющую аргументы, таким образом, чтоб вызывать ее, вообще не указывая при этом никаких аргументов. Однако для этого при объявлении функции необходимо задать значения ***аргументов по умолчанию***.
Если при вызове функции число переданных аргументов на единицу меньше, чем описано в прототипе, то компилятор считает, что отсутствует последний аргумент и установит его значение по умолчанию.
Обратите внимание, что опускать при вызове можно только аргументы, стоящие в конце списка при объявлении функции. Задание значений аргументов по умолчанию полезно в тех случаях, когда аргументы функции часто принимают какое-то одно значение. 
***Область видимости*** определяет, из каких частей программы возможен доступ к переменной, а 
***класс памяти*** — время, в течение которого переменная существует в памяти компьютера.
Переменные, имеющие ***локальную область видимости***, доступны внутри того блока, в котором они определены.
Переменные, имеющие ***область видимости файла***, доступны из любого места файла, в котором они определены.
***Блоком*** обычно считается код, заключенный в фигурные скобки.
Существует два класса памяти: ***automatic*** (автоматический) и ***static*** (статический).
У переменных, имеющих класс памяти ***automatic***, время жизни равно времени жизни функции, внутри которой они определены.
У переменных, имеющих класс памяти ***static***, время жизни равно времени жизни всей программы.
Статические локальные переменные используются в тех случаях, когда необходимо сохранить значение переменной в памяти после того, как выполнение функции будет завершено, или, другими словами, между вызовами функций.
Подобно тому как мы передавали в функцию аргументы с помощью ссылок, мы можем возвращать значение функции по
ссылке (Виртуальные функции) для избежания копирования больших объектов. Функция, возвращающая ссылку, интерпрети-
руется как переменная. С помощью ссылки вы не можете возвратить из функции константу.
В случае, если аргумент занимает много места в памяти, его передача по ссылке является гораздо более эффективной, поскольку в последнем случае в функцию передается не значение переменной, а только ее адрес.
Предположим, что вы используете ссылочный механизм только из соображений эффективности и при этом не хотите, чтобы функция имела свободный доступ к аргументу и изменяла его значение. Для того чтобы получить подобную гарантию, вы можете указать модификатор const перед соответствующим аргументом в прототипе функции.
Если вы желаете передать в функцию константную переменную с помощью ссылки, у вас не остается другого выбора, как использовать модификатор const в прототипе функции.

# **Глава 6**
# **Объекты и классы**
Объект является экземпляром класса, так же, как автомобиль является экземпляром колесного средства передвижения. 
Ключевой особенностью объектно-ориентированного программирования является возможность сокрытия данных. Этот термин понимается в том смысле, что данные заключены внутри класса и защищены от несанкционированного доступа функций, расположенных вне класса. Если необходимо защитить какиелибо данные, то их помещают внутрь класса с ключевым словом ***private***. Такие данные доступны только внутри класса. Данные, описанные с ключевым словом ***public***, напротив, доступны за пределами класса.
Сокрытие данных в нашем толковании означает ограждение данных от тех частей программы, которые не имеют необходимости использовать эти данные. В более узком смысле это означает сокрытие данных одного класса от другого класса. Сокрытие данных позволяет уберечь опытных программистов от своих собственных ошибок. Программисты могут сами создать средства доступа к закрытым данным, что значительно снижает вероятность случайного или некорректного доступа к ним.
***Данные***, содержащиеся внутри класса, называют данными-членами или ***полями класса***. Число полей класса, как и у структуры, теоретически может быть любым.
***Методы класса*** — это функции, входящие в состав класса.
Методы класса, определенные внутри класса, по умолчанию являются встраиваемыми. Функция, определенная вне класса, по умолчанию уже не является встраиваемой. Доступ к методам класса возможен только через конкретный объект этого класса.
Обратите внимание на то, что при определении класса не создаются никакие его объекты. Определение класса лишь задает вид будущего объекта, подобно тому, как определение структуры не выделяет память под структурные переменные, а лишь описывает их организацию. Все операции программа производит с объектами. Определение объекта похоже на определение переменной: оно означает выделение памяти, необходимой для хранения объекта.
Для того чтобы получить доступ к методу класса, необходимо использовать операцию точки (.) (операцию точки называют операцией доступа к члену класса).
Удобнее инициализировать поля объекта автоматически в момент его создания, а не явно вызывать в программе соответствующий метод. Такой способ инициализации реализуется с помощью особого метода класса, называемого конструктором. ***Конструктор*** — это метод класса, выполняющийся автоматически в момент создания объекта. При создании каждого объекта вызывается конструктор класса, присваивающий полям нулевое значение по-умолчанию. Имя конструктора в точности совпадает с именем класса. Таким образом, компилятор отличает конструкторы от других методов класса. У конструкторов не существует возвращаемого значения.
Counter()
{ count = 0; }
Такая форма записи не рекомендуется, несмотря на то, что она не содержит ошибок. 
Инициализация в нашем примере происходит следующим образом:
Counter() : count(0) { }
Список инициализации:
SomeClass() : m1(7), m2(33), m3(4) { }
Инициализация полей с помощью списка инициализации происходит до начала исполнения тела конструктора, что бывает важно.
Конструктор без параметров называется ***конструктором по умолчанию***. Если бы конструктор по умолчанию не создавался автоматически, то мы не смогли бы определять переменные классов, в которых отсутствует конструктор.
Если же для нас важно, какими значениями будут инициализироваться поля объекта класса, то нам следует явно определить конструктор.
Два явно определенных конструктора с одним и тем же именем является ***перегруженным***.
В примере ENGLCON метод add_dist() определен вне класса Distance(). Внутри определения класса содержится лишь прототип функции add_dist();
void Distance::add_dist(Distance dd1, Distance dd2)
:: - символ является знаком ***операции глобального разрешения***. Такая форма записи устанавливает взаимосвязь функции и класса, к которой относится эта функция.
Рассмотрим третий способ инициализации объекта, использующий значения полей уже существующего объекта. ***Копирующим конструктором по умолчанию***. Копирующий конструктор имеет единственный аргумент, являющийся объектом того же класса, что и конструктор.
Distance dist1(11, 6.25); // конструктор с двумя аргументами
Distance dist2(dist1);	// два конструктора с одним аргументом
Distance dist3 = dist1;
Мы инициализировали объект dist1 значением 11'-6.25" при помощи конструктора с двумя аргументами. Затем мы определяем еще два объекта класса Distance с именами dist2 и dist3, оба из которых инициализируются значением объекта dist1. Поскольку аргументом являлся объект того же класса, был вызван копирующий конструктор по умолчанию. Distance dist2(dist1) Действие копирующего конструктора по умолчанию сводится к копированию значений полей объекта dist1 в соответствующие поля объекта dist2. 
Идентичные действия для пары объектов dist1 и dist3 выполняются при помощи оператора Distance dist3 = dist1; Здесь, как и в предыдущем случае, вызывается конструктор копирования по умолчанию.
***Деструкторы*** - функция, автоматически вызываемая при уничтожении объекта. Деструктор имеет имя, совпадающее с именем конструктора и предваряющееся символом ~. Подобно конструкторам, деструкторы не возвращают значения и не имеют аргументов.
***Структуры*** предназначены для объединения данных, а ***классы*** — для объединения данных и функций. На самом деле, в большинстве ситуаций можно использовать структуры так же, как и классы. Формально ***разница между структурами и классами*** заключается лишь в том, что по умолчанию все члены класса являются скрытыми, а все члены структуры — открытыми.
Если поле данных класса описано с ключевым словом ***static***, то значение этого поля будет одинаковым для всех объектов данного класса.
Статические данные класса полезны в тех случаях, когда необходимо, чтобы все объекты включали в себя какое-либо одинаковое значение. Статическое поле по своим характеристикам схоже со статической переменной: оно видимо только внутри класса, но время его жизни совпадает со временем жизни программы. ***Определение статических полей*** класса происходит не так, как для обычных полей. Объявление поля находится внутри определения класса, а определение поля располагается вне класса и зачастую представляет собой определение глобальной переменной. Если бы определение статического поля класса находилось внутри класса, то это нарушило бы принцип, в соответствии с которым определение класса не должно быть связано с выделением памяти. Если вы объявите статическое поле класса, но забудете его определить, компилятор не выдаст предупреждающего сообщения.
В памяти компьютера каждый объект имеет свои собственные участки, хранящие значения полей этого объекта, но методы класса хранятся в памяти в единственном экземпляре.
***Константные методы класса***
Константные методы ***const*** отличаются тем, что не изменяют значений полей своего класса. Те методы, которые лишь считывают данные из поля класса, имеет смысл делать константными, поскольку у них нет необходимости изменять значения полей объектов класса. С помощью константных функций можно создавать и использовать константные объекты, как мы увидим позже.
***Константные аргументы методов***
Если необходимо передать аргумент в функцию ***по ссылке*** и в то же время ***защитить его от изменения функцией***, необходимо сделать этот аргумент константным при объявлении и определении функции.
***Константные объекты***
Если объект класса объявлен с модификатором ***const***, он становится недоступным для изменения. Это означает, что для такого объекта можно вызывать только константные методы.
const Distance football(300, 0);
Когда вы создаете класс, всегда является хорошим стилем объявлять константными функции, не изменяющие полей объектов класса. Это позволяет тому, кто использует данный класс, создавать константные объекты класса. Из этих объектов могут вызываться только константные функции.
Первым достоинством ***объектно-ориентированного программирования*** является то, что оно обеспечивает значительное сходство между объектами реального мира, моделируемыми программой, и объектами классов C++.

# **Глава 7**
# **Массивы и строки**
Массив - механизм группировки данных. Данные, сгруппированные в массиве, могут быть как основных типов, таких, как int или float, так и определенных пользователем типов, таких, как структуры или объекты. В массиве группируются однотипные данные. Доступ к элементам массива — по ***индексу***.
Для массива необходимо указать размер, который определяет, сколько элементов массив может содержать. Размер следует за именем и заключается в квадратные скобки int days_per_month[12]
Не нужно использовать размер массива, когда мы инициализируем все элементы массива, так как компилятор может его вычислить, подсчитав инициализированные переменные. Таким образом, мы можем записать
int days_per_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
Если инициализированы только несколько элементов, то оставшимся элементам будет присвоено значение 0. Если же инициализаций будет слишком много, то компилятор выдаст ошибку.
Массивы могут быть ***многомерными*** double sales[DISTRICTS][MONTHS];
Трехмерный массив — это массив массивов, которые состоят из массивов. Доступ к элементам массива осуществляется с использованием трех индексов: elem = dimen3[x][у][z];
cout << setiosflags(ios::fixed) << setiosflags(ios::showpoint) << setprecision(2) << setw(10) << fpn;
Флаг fixed предотвращает печать числа в экспоненциальной форме, например 3.45e3. 
Флаг showpoint определяет положение десятичной точки, даже если число не имеет дробной части: 123.00 вместо 123.
Для установки точности до двух знаков после запятой используйте метод setprecision с числом в качестве аргумента. 
Ширину поля, используя метод setw.
Массивы могут быть использованы как аргументы функций. В объявлениях функции массивы-аргументы представлены типом данных и размером. 
void display(double[DISTRICTS][MONTHS]);
Нa самом деле здесь есть один необязательный элемент. Следующее объявление работает так же:
void display(double[][MONTHS]);
Отсюда следует, что если мы объявили функцию с одномерным массивом в качестве аргумента, то нам не нужно указывать размер массива:
void somefunc(int elem[]);
При вызове функции в качестве аргумента используется только имя массива ***display(elem)***;
Имя elem в действительности представляет собой ***адрес массива в памяти***. Использование адресов для массивов-аргументов ***похоже на*** использование аргумента ***ссылки***, при котором значения элементов массива не дублируются (копируются) в функции. Вместо этого функция работает с оригинальным массивом, хотя ссылается на него, используя другое имя. Эта система используется для массивов, потому что они могут быть очень большими.
Однако ***адрес*** — это не то же самое, что и ссылка. С именем массива не используется амперсанд (&) при объявлении функции. Массивы передаются в функцию только с использованием их имени и функция работает при этом с оригиналом массива, а не с его копией.
Массивы могут содержать в себе не только данные основных типов, но и структуры. ***Массивы структур*** — это полезный тип данных, используемый в различных ситуациях.
Массивы могут быть использованы в качестве ***полей класса***. Давайте рассмотрим пример, стек. ***Стек*** работает как пружинное устройство, удерживающее патроны в магазине. Функции передают аргументы и хранят возвращаемые адреса в стеке.
Класс stack является примером важной возможности ООП; он используется для реализации контейнера или механизма для хранения данных. Стек может быть использован не только для этой цели. Он применяется в связных списках, очередях, группах и т. д.
Мы можем создать массив объектов.
Что случится если введется в массив большее число элементов, чем возможно ? В C++ нет проверки границ массива. Если программа поместит что-то за пределами массива, то компилятор и исполняемая программа протестовать не будут. Однако эти данные могут быть записаны поверх других данных или поверх самой программы. Это может послужить причиной странных эффектов или даже полного краха системы.
***Строки*** В C++ используются два вида строк: строка как массив символов типа ***char*** и строка как объект класса ***string***. В этом разделе мы опишем первый тип строк, строка — это массив элементов типа char. Тем не менее строки, созданные с помощью класса string, во многих ситуациях вытеснили строковый тип. Но строковый тип все еще используется по многим причинам. Во-первых, он используется во многих библиотечных функциях языка C. Во-вторых, он год за годом продолжает появляться в кодах. И в-третьих, для изучающих C++ строковый тип наиболее примитивен и поэтому легко понимается на начальном уровне.
***Строковые переменные***
Как и другие типы данных, строки могут быть ***переменными*** и ***константами***. char str[100];
Каждый символ занимает 1 байт памяти. Важная деталь, касающаяся строк, состоит в том, что они должны завершаться байтом, содержащим 0. Это часто представляют символьной константой \0, код которой в ASCII равен 0. Завершающий ноль называется нулевым символом.
В C++ нет встроенного механизма, защищающего программу от помещения элементов за пределы массива. Однако существует возможность ограничить при использовании операции >> количество символов, помещаемых в массив. 
cin >> setw(MAX) >> str; // ввод не более чем MAX-1 символов. Метод setw определяет максимальное количество символов, которое сможет принять буфер.
***Строковые константы*** Вы можете инициализировать строку постоянным значением при ее определении. 
char str[] = "Я памятник себе воздвиг нерукотворный.";
Операция >> считает пробел нулевым символом. Таким образом, он считывает строки, состоящие из одного слова, и что-либо, напечатанное после пробела, отбрасывается.
Для считывания строк, содержащих пробелы, мы используем другой метод — cin.get(). Этот синтаксис означает использовать метод get() класса stream для его объекта cin.
cin.ignore();
cin.get();
***Считывание нескольких строк*** Оказывается, что метод cin.get() может иметь третий аргумент, который пригодится нам в этой ситуации. Этот аргумент определяет символ, на котором метод завершает считывание строки. Установленным по умолчанию значением является'\n', но если вы вызовете метод с другим аргументом, то это значение заменится на введенный вами символ.
cin.get(str, MAX, '$');
***Копирование строк***
Функция strlen() определяет длину строки (сколько символов строка содержит). Мы используем длину строки для ограничения цикла for, чтобы скопировать нужное нам количество символов. Скопированная версия строки должна заканчиваться нулевым символом. Однако длина строки, возвращаемая функцией strlen(), не включает в себя нулевой символ. Мы могли скопировать один добавочный символ, но проще вставить нулевой символ явно.
***Копирование строк более простым способом***
Конечно, вам не обязательно использовать цикл for для копирования строк. Для этого существует библиотечная функция strcpy(). Заметим, что первым аргументом этой функции является строка, куда будут копироваться данные:
strcpy(destination, source);
Порядок записи справа налево напоминает формат обыкновенного присваивания: переменная справа копируется в переменную слева. Похожая функция strncpy() принимает еще третий аргумент, определяющий максимальное количество символов, которое может быть скопировано.
При использовании строкового типа в C++ вы не можете использовать выражение strDest = strSrc; для установки равенства одной строки другой. В стандартном классе C++ string эта проблема решена.
Альтернативный формат вызова этого конструктора, одноаргументным конструктором, будет таким:
String s1 = "С Новым годом! ";
***Стандартный класс string языка C++***
Вам не нужно заботиться о создании массива нужного размера для содержания строковых переменных. Класс string берет на себя ответственность за управление памятью. Этот класс позволяет использовать перегруженные операции, объединять строковые объекты, используя операцию +: ***s3 = s1 + s2***; Этот класс более эффективен и безопасен в использовании, чем строковый тип.
Определить объект класса string можно различными способами: использовать конструктор без аргументов, создающий пустую строку и конструктор с одним аргументом, где аргумент является строковой константой, символы ограничены двойными кавычками.
string s1("Рыба");
string s2 = "Мясо";
string s3;
метод класса string ***swap()*** — меняет местами значения двух строковых объектов. Он вызывается для одного объекта, в то время как другой объект является его аргументом bs1.swap(bs2);
Операции << и >> перегружены для использования с объектами класса string, метод getline() принимает ввод, который может содержать пробелы или несколько строк.
Программа считывает имя пользователя, которое, возможно, содержит внутренние пробелы, используя метод ***getline()***. Эта функция похожа на метод get(), используемый для строкового типа, но это не метод класса. Первым аргументом является потоковый объект, из которого будет приниматься ввод (cin), а второй аргумент — это объект класса string, куда будет помещен текст.
Класс string включает в себя различные методы для поиска строк и фрагментов строк в объектах класса string. Метод ***find()*** предназначен для поиска строки, используемой в качестве аргумента, в строке, для которой был вызван метод. Метод ***find_first_of()*** предназначен для поиска любого символа из группы и возвращает позицию первого найденного. Похожий метод ***find_first_not_of()*** ищет первый символ в строке, который не
входит в определенную группу символов. Функция ***rfind()***, переворачивающая строку, ***find_last_of()***, ищущая последний символ, совпадающий с группой заданных символов и ***find_last_not_of()***. Все эти функции возвращают -1, если цель не найдена.
Существуют различные пути модификации объектов класса string. Метод ***erase()*** удаляет фрагмент из строки. Его первым аргументом является позиция первого символа фрагмента, а вторым — длина фрагмента. Метод ***replace()*** заменяет часть строки на другую строку. Его первым аргументом является позиция начала замены, вторым — количество символов исходной строки, которое должно быть заменено, а третьим аргументом является строка для замены. Метод ***insert()*** вставляет строку, определенную во втором аргументе, на место, определенное в первом аргументе. Метод ***size()*** возвращает количество символов в объекте класса string. Метод ***append()*** ставит знаки в конце. В этой версии метода первый аргумент — это количество символов, которое будет добавлено, а второй аргумент — это символы, которые будут добавлены.
Можно использовать перегруженные операции или метод ***compare()*** для сравнения объектов класса string. Задача состоит в том, чтобы определить, являются ли строки идентичными или какая из них предшествует другой в алфавитном порядке. 
userName.compare(0, 2, aName, 0, 2);
Аргументами метода ***compare()*** являются начальная позиция userName, число символов, которые надо сравнить, строка, используемая для сравнения (aName), а также начальная позиция и количество символов в строке aName.
Метод ***substr()*** возвращает фрагмент строки, для которой метод был вызван. Его первый аргумент — это позиция фрагмента, а второй — количество символов.
Доступ к отдельным символам объектов класса string вы можете получить разными способами. Вы можете использовать перегруженную операцию ***[]***, которая позволяет рассматривать объект класса string как массив. Однако операция [] не предупредит вас, если вы попытаетесь получить доступ к символу, лежащему за пределами массива в отличии от метода ***at()***.
Метод ***copy()*** для копирования объекта класса string в массив типа char, эффективно преобразовывая его в строковый тип.
Метод ***length()*** класса string возвращает то же число, что и метод ***size()***.
Можно также преобразовать объект класса string к строковому типу, используя методы ***c_str()*** или ***data()***.
Метод ***capacity()*** возвращает действительное количество занятой памяти. Вы можете добавлять символы в строку, не добавляя памяти в нее до тех пор, пока этот лимит не будет исчерпан.
Метод ***max_size()*** возвращает максимально возможный размер объекта класса string. Это количество будет на три байта меньше, чем максимальное значение переменной типа int в вашей системе.
Объекты класса string не заканчиваются ***нулевым символом***, как это происходит в строковом типе. Строковый тип представляет собой массив элементов типа char. Последний символ такой строки должен быть нулевым, '\0'.

# **Глава 8**
# **Перегрузка операций**
Перегрузка операций — это одна из самых захватывающих возможностей ООП. Она может превратить сложный и малопонятный листинг программы в интуитивно понятный. Например, строки d3.addobjects(d1, d2); похожие, но одинаково непонятные
d3 = d1.addobjects(d2); можно заменить на более читаемую 
d3 = d1 + d2;
Довольно непривлекательный термин «перегрузка операций» дается обычным операциям C++, таким, как +, *, <= или +=, в случае их применения с определенными пользователем типами данных.
а = b + с; работают только с основными типами данных, такими, как int или float, и попытка использования обычных операторов, когда a, b и с являются объектами определенного пользователем класса, приведет к протестам компилятора.
Как использовать обычные операции с определенными пользователями типами? В этом объявлении использовано ключевое слово ***operator*** для перегрузки операции ++:
***void operator++()***
Сначала пишут возвращаемый тип (в нашем случае void), затем ключевое слово operator, затем саму операцию (++) и наконец список аргументов, заключенный в скобки (здесь он пуст). Такой синтаксис говорит компилятору о том, что  если операнд принадлежит классу Counter, то нужно вызывать функцию с таким именем, встретив в тексте программы операцию ++.
Вы можете его выявить, если используете в функции main() строку, похожую на эту:
c1 = ++c2;
Компилятор будет протестовать потому, что мы определили тип void для возвращаемого значения функции operator++(). А в нашем выражении присваивания будет запрошена переменная типа Counter. То-есть компилятор запросит значение переменной c2, после того как она будет обработана операцией ++, и присвоит ее значение переменной c1.
Counter operator++() {
	++count;
	Counter temp;
	temp.count = count;
	return temp;
}
***Постфиксные операции***
Теперь у нас есть два типа объявления функции operator++. С одной из них, для префиксной операции, мы уже были знакомы ранее:
Counter operator++();
Для реализации постфиксной записи операции ++ используем новую функцию:
Counter operator++(int);
Различие между этими функциями только в том, что в скобках стоит int. Здесь int не играет роли аргумента и не означает целое число. Это просто сигнал для компилятора, чтобы использовалась постфиксная версия операции. Разработчики C++ нашли полезным повторное использование существующих операций и ключевых слов; в данном случае int предназначена также и для обозначения постфиксной операции.
***Перегрузка бинарных операций***
Бинарные операции могут быть перегружены так же, как и унарные операции.
***Арифметические операции***
Используя перегрузку операции +, мы можем отказаться от dist3.add_dist(dist1, dist2); выражения и воспользоваться таким: dist3 = dist1 + dist2;
// сложение двух длин
Distance operator+(Distance) const;
Эта операция возвращает значение типа Distance и принимает один аргумент типа Distance. Но какой из объектов используется в качестве аргумента этой операции — dist1 или dist2?
Существует правило: объект, стоящий с левой стороны операции (в нашем случае dist1), вызывает функцию оператора. Объект, стоящий справа от знака операции (dist2), должен быть передан в функцию в качестве аргумента. Операция возвращает значение, которое мы затем используем для своих нужд. В нашем случае мы присваиваем его объекту dist3. В функции operator+() к левому операнду мы имеем прямой доступ, используя feet и inches, так как это объект, вызывающий функцию. К правому операнду мы имеем доступ как к аргументу функции, то есть как d2.feet и d2.inches.
Мы можем обобщить изложенное выше и сказать, что перегруженной операции всегда требуется количество аргументов на один меньшее, чем количество операндов, так как один из операндов является объектом, вызывающим функцию. Поэтому для унарных операций не нужны аргументы (это правило неверно для функции и операторов, являющихся дружественными для класса ГЛАВА 11).
***Объединение строк***
Операция + не может быть использована для объединения строк: str3 = str1 + str2; где str1, str2 и str3 — строковые переменные (массивы типа char). Однако если мы будем использовать свой собственный класс String из программы STROBJ главы 6, то мы сможем перегрузить операцию + для объединения строк. Это же делает и стандартный класс string в C++.

