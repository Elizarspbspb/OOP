# **WinDbg**
***WinDbg*** — это отладчик, который можно использовать для анализа аварийных дампов, отладки динамического кода в пользовательском и режиме ядра, а также для анализа регистров ЦП и памяти.
![Alt text](IMAGES/Screenshot_1.png)
Первая область: окно, где выводится результат выполнения команд.
Вторая область: небольшое текстовое поле для ввода команд.

## **Проверка и загрузка символов**

***Символы*** – это файлы, которые генерируются вместе с исполняемым файлом во время компиляции программы и содержат отладочную информацию (функции и имена переменных). Отладочная информация позволяет исследовать функциональность приложения во время отладки или дизассемблирования. Многие компоненты Microsoft компилируются вместе с символами, которые распространяются через Microsoft Symbol Server.
![Alt text](IMAGES/image.png)
Если нужно импортировать символы во время отладки, то можно сделать это при помощи .sympath 

`0:000> .sympath+ c:\SomeOtherSymbolFolder`

Затем выполнить перезагрузку символов

`0:000> .reload`

Чтобы увидеть, для каких модулей загружены символы можно воспользоваться командой x*!. Команда x*! покажет символы, которые могут быть загружены.

`0:000> x*!`

Можно принудительно загрузить символы при помощи команды ld*

`0:000> ld*`
![Alt text](IMAGES/image-3.png)

Символы особенно хороши тем, что дают нам информацию о местонахождении известных функций. Мы можем использовать смещения к этим функциям в качестве адресов в точках останова. Для того чтобы выяснить смещение, используйте команду `u`.




## **Отладка локального процесса**
Локальную отладку процесса можно осуществить 2 способами:

    1. Подцепиться к уже запущенному процессу.
    Зайти в «File:Attach to a Process» и выбрать PID или имя процесса.
    2. Запустить процесс через WinDBG.
    Зайти в «File:Open Executable» и выбрать исполняемый файл для отладки.

Если запуск программы происходит с помощью WinDBG, то подключаются специальные отладочные опции (например, отладка кучи), которые могут привести к краху приложения. Но существуют программы, которые аварийно заканчиваются свою работу, когда к ним подключается отладчик. Обычно вредоносы проверяют присутствие отладчика в системе и могут не запуститься, тогда следует цепляться к запущенному процессу. Иногда происходит отладка службы под управлением ОС Windows, которая устанавливает некоторые параметры во время запуска, так что для упрощения процесса отладки, также лучше подцепляться к запущенному процессу, а не запускать службу через отладчик.

Чтобы подцепиться к уже запущенному процессу зайдите в «File:Attach to a Process», а затем выберите PID или имя процесса. Помните о том, что вам необходимо иметь соответствующие права, чтобы подцепиться к процессу.

## **Отладка удаленного процесса**

Если вы уже начали локальную отладку программы (посредством подключения или запуска процесса через WinDBG), то можете ввести определенную команду:

`.server tcp:port=5005`

и WinDBG запустит «слушатель» (listener), к которому сможет подключиться удаленный отладчик.

Теперь вы может подключиться с удаленного хоста к уже существующей отладочной сессии, зайдя в «File:Connect to a Remote Session» и введя в текстовое поле примерно следующее:
![Alt text](IMAGES/image-1.png)

## **Создание удаленного сервера**

Вы также можете создать отдельный сервер с WinDBG, удаленно подключаться к нему и выбирать процесс для отладки. Это можно сделать используя команду:

`dbgsrv.exe -t tcp:port=5005`

К серверу отладки вы можете подключиться, если зайдете в файл «File: Connect to Remote Stub» и введете в текстовое поле следующую строку: 

`tcp:Port=5005,Server=192.168.127.138`

## **Система помощи**
Команда `.hh` для доступа к справке WinDBG

Вы также можете получить справочную информацию по определенной команде: `.hh .reload`

![Alt text](IMAGES/image5.png)

## **Модули**

Во время работы программы импортируются различные модули, обеспечивающие функциональность приложения. Следовательно, если вы будете знать, какие модули импортированы приложением, то сможете лучше понять алгоритм его работы. Во многих случаях, вы будете отлаживать конкретный модуль, загруженный программой, а не сам исполняемый файл.

`lmf` - вывод модулей

`lmf m NAME` - адрес загрузки для конкретного модуля

`!dh NAME` - информацию о заголовке (image header) конкретного модуля

## **Сообщения и исключения**
Например, когда мы цепляемся к calc.exe, WinDBG автоматически устанавливает точку останова (которая является просто маркером, используемым для остановки приложения). Информация о точке останова выводится на экран:

`(da8.b44): Break instruction exception - code 80000003 (first chance)`

Конкретно это сообщение является исключением (first-chance). Исключение – это особое состояние, возникающее во время выполнения программы. First-chance исключение означает, что программа остановилась сразу же после появления исключения. Second-chance исключение означает, что после возникновения исключения будут выполнены некоторые операции, а потом программа остановит свою работу.

## **Регистры**
***Регистры*** – это специальные переменные внутри процессора, которые хранят небольшие куски информации или следят за состоянием чего-либо в памяти. Процессор может обрабатывать информацию в этих регистрах очень быстро. Это намного быстрее, чем каждый раз получать информацию по шине из RAM.

`r` - команда повторного отображения регистров
![Alt text](IMAGES/image4.png)

`r eax,ebp` - информация о конкретных регистрах

## **Указатель на инструкцию**
ntdll!DbgBreakPoint:

77db1a92    cc  int     3

Эквивалентный результат команды - `u eip L1`

77db1a92 - то, что содержится в регистре EIP. (`r eip`)
EIP – это регистр, содержащий местонахождение следующей инструкции, которую должен выполнить процессор. WinDBG идет по адресу, указанному в регистре EIP, преобразует этот участок в ассемблерный код и отображает его на экране.

## **Точки останова**
Точки останова – это маркеры, связанные с определенным адресом памяти, при достижении которых процессор останавливает выполнение программы. Приложение может состоять из миллионов ассемблерных инструкций, и проходить через каждую из них. Точки останова значительно сокращают время отладки, когда вы устанавливает маркер на определенную функцию, а процессор, автоматически выполняя весь предыдущий код, останавливается в нужном вам месте. Как только достигнута точка останова, программа останавливается, и вы можете начать отладку.

**Программные точки останова**

Перед выполнением программа сначала загружается в память, что позволяет нам временно контролировать участок памяти, связанный с программой, без влияния на процесс ее выполнения. Именно так и работают программные точки останова. Отладчик запоминает ассемблерную инструкцию (на которой мы хотим остановиться), где должна быть вставлена точка останова, затем заменяет ее на ассемблерную инструкцию **INT 3 (0xcc)**, которая заставляет процессор остановить выполнение программы. Как только точка останова достигнута, отладчик считывает текущий адрес памяти, достает ранее записанную инструкцию и показывает ее пользователю. Пользователю кажется, что программа остановился на этой инструкции, однако процессор не имеет ни малейшего представления о ее существовании.

В WinDBG программные точки останова устанавливаются при помощи команд `bp, bm, или bu`. Команда `bp (Break Point)`, вероятно, наиболее часто используемая команда, при помощи которой устанавливаются точки останова. Адрес, передаваемый команде bp, должен быть участком памяти с исполняемым кодом. Поскольку команда bp работает с памятью, где хранятся данные, то в некоторых случаях могут возникнуть проблемы, так как отладчик перезаписывает информацию, которая находится в участке памяти. Во избежание проблем компания Microsoft рекомендует использовать команду `ba` (о ней мы поговорим дальше) в случае, если вы работаете с памятью, где хранятся данные.

По умолчанию, при запуске программы через WinDBG, отладчик устанавливает точку останова в самом начале программы. Для определения начального адреса загрузки программы воспользуемся командой:

`lmf m NAMEMODUL`.

![Alt text](image.png)

Далее, используя адрес загрузки (start) и команду `!dh`, находим точку входа программы (address of entry point):

![Alt text](image-1.png)

Теперь устанавливаем точку останова в точку входа (адрес загрузки + address of entry point):

`bp 4012E0`

![Alt text](image-2.png)

Не всегда обязательно складывать в уме, можно с помощью WinDBG:

`bp 00400000 + 12E0`

В большинстве случаев используются программные точки останова, однако иногда понадобятся аппаратные точки останова (например, когда у памяти установлен атрибут «только чтение» или когда информация защищена и т. д.).

**Аппаратные точки останова (процессорные)**

Внутри большинства процессоров существуют специальные отладочные регистры, которые можно использовать для хранения адресов точек останова и специальных условий доступа, по которым срабатывают эти точки останова (например, на чтение, запись или выполнение). Точки останова, хранящиеся в таких регистрах, называются аппаратными (или процессорными) точками останова. Когда процессор доходит до адреса памяти, который определен внутри отладочного регистра и выполняются условия доступа, программа останавливается.

`ba` - команда аппаратной точки останова

![Alt text](image-3.png)

Первый аргумент e – тип доступа к памяти (на выполнение), второй аргумент – размер (всегда 1 для этого типа доступа). Последний аргумент – адрес.

Из-за способа, при помощи которого Windows сбрасывает контексты потока, и места, где появляется WinDBG после порождения процесса, мы не сможем установить точку останова тем же самым способом, как делали это в предыдущем примере. Ранее мы устанавливали точку останова во входной точке приложения, но если сделать так же и здесь, то возникнет ошибка:
![Alt text](image-4.png)

Для решения этой проблемы нам нужно использовать команду `g`, чтобы программа добралась до определенного адреса памяти. Когда мы устанавливали программную точку останова, то делали примерно то же самое, но не совсем. Таким образом, мы заставляем WinDBG дойти до начального контекста потока, что впоследствии позволит нам устанавливать аппаратные точки останова. Чтобы убедиться в том, что точка останова хранится в регистре процессора, можно использовать команду `r`. Атрибут `M` нужен для использования маски регистра `0x20`:

![Alt text](image-6.png)

Первый раз во всех регистрах находятся нули! Такое произошло потому, что WinDBG еще ничего не занес ни в один из этих регистров. После того, как вы продвинетесь на один шаг вперед, используя команду `p`, то в регистр ***dr0*** установится адрес нашей точки останова.

## **Команды для работы с точками останова**

**`bl`** - просмотр всех установленных точек останова.
![Alt text](image-7.png)

0 – Идентификатор точки останова

e – Статус точки останова - активирована (enabled) или деактивирована (disabled).

e 1 – Флаг доступа к адресу памяти (execute) и размер – только для аппаратных точек останова

0001 (0001) – сколько раз должна сработать точка останова перед тем, как она станет активной. В скобках указано общее количество проходов (для особого варианта использования)

0:**** - Информация о потоке и процессе. Данное обозначение показывает, что точка останова не специфична для потока

**`bc 0`** - Удаление точек останова. По желанию можно указать символ *, чтобы удалить все точки останова.

**`u`** - возьмет информацию по указанному адресу и отобразит ее в виде ассемблерных инструкций. Кроме того, команда `u` выводит смещение до ближайшего символа `u 00400000 + 12E0`.
![Alt text](image-8.png)

hello+0x12e0 - является аналогом адресу 004012E0
Если бы в конце этого имени не стояло числового смещения, то для этой функции существовали бы символы. В этот раз мы получили имя функции hello плюс смещение (+0x12e0). Я точно не знаю, почему WinDBG добавляет смещение. Вероятно, влияет порядок сортировки во время поиска символов. Тем не менее, мы можем добавить свое смещение, чтобы сослаться на ту же самую область памяти:
![Alt text](image-9.png)

Вся фишка в том, что мы можем использовать это смещение во время установки точки останова, и эти смещения всегда корректны, даже когда работает ASLR. То есть нам не нужно высчитывать адреса при каждом запуске.

## **Прерывание загрузки модуля**

На практике может возникнуть необходимость в установке точки останова во время загрузки модуля. Мы можем добавить подобную точку останова, путем установки исключения при помощи команды `sxe`, возникающего во время загрузки модуля:
Мы можем увидеть все установленные исключения, используя команду `sx` (Set Exceptions). Убрать исключение можно при помощи команды `sxi` (Set Exception Ignore).

## **Выполнение команд при срабатывании точки останова**

В WinDBG весь процесс можно автоматизировать при помощи выполнения цепочки команд, привязанных к точке останова. В нашем примере мы будем выводить на экран информацию из стека при помощи команды `dd`.

`bp hello + 12E0 ".echo \"Here are the values on the stack:\n\"; dd esp;"`

![Alt text](image-10.png)

---------------------------
Краткая инструкция:

1. Проверить наличие символов - **`x*!`**

2. Принудительно загрузить символы **`ld*`**

3. Вывести все модули **`lmf`**

4. Определить точку входа программы **`!dh NAMEMODUL`**

5. Определить и установить точку останова для отладки **`bp 4012E0`**